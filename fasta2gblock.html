<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FASTA Fragment Tiler</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;800&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-gradient: linear-gradient(to bottom, #f3f4f6, #14b8a6);
      --bg-container: #ffffff;
      --text-color: #374151;
      --svg-bg: #ffffff;
      --svg-text: #231f20;
      --svg-text-red: #ba2025;
      --output-bg: #f9fafb;
      --text-gray-600: #4b5563;
      --text-gray-700: #374151;
      --text-gray-500: #6b7280;
      --link-color: #4f46e5;
      --link-hover: #0d9488;
      --histogram-bar: #14b8a6;
      --histogram-bar-hover: #0d9488;
      --histogram-grid: #d1d5db;
    }
    [data-theme="dark"] {
      --bg-gradient: linear-gradient(to bottom, #1f2937, #065f46);
      --bg-container: #1f2937;
      --text-color: #e5e7eb;
      --svg-bg: #1f2937;
      --svg-text: #f3f4f6;
      --svg-text-red: #f87171;
      --output-bg: #ffffff;
      --text-gray-600: #d1d5db;
      --text-gray-700: #e5e7eb;
      --text-gray-500: #9ca3af;
      --link-color: #5eead4;
      --link-hover: #99f6e4;
      --histogram-grid: #4b5563;
    }
    body {
      background: var(--bg-gradient);
      font-family: 'Inter', sans-serif;
      color: var(--text-color);
      min-height: 100vh;
      margin: 0;
      padding: 0;
      position: relative;
    }
    .container {
      background: var(--bg-container);
      position: relative;
      min-height: 100vh;
    }
    pre {
      white-space: pre-wrap;
      overflow-x: auto;
      max-height: 400px;
      background: var(--output-bg);
      color: #000000;
    }
    #outLog {
      color: #000000;
    }
    [data-theme="dark"] #outLog {
      color: #000000;
    }
    svg {
      display: block;
      margin: 1.5rem auto;
      width: 100%;
      max-width: 100%;
      height: auto;
    }
    p {
      font-size: 1.1rem;
      line-height: 1.6;
    }
    .st3, .st6 {
      font-size: 12px;
    }
    .st7 {
      fill: var(--svg-bg);
    }
    .st3, .st4 {
      fill: var(--svg-text);
    }
    .st6 {
      fill: var(--svg-text-red);
    }
    .st0, .st1 {
      fill: none;
      stroke: var(--svg-text);
      stroke-miterlimit: 10;
    }
    .st2 {
      fill: var(--svg-text);
    }
    .st1 {
      stroke-dasharray: 3.74 1.87;
    }
    footer {
      text-align: center;
      padding: 1rem 0;
    }
    table {
      width: 100%;
      border-collapse: collapse;
    }
    th, td {
      border: 1px solid #e5e7eb;
      padding: 8px;
      text-align: left;
    }
    tr:nth-child(even) {
      background-color: #f9fafb;
    }
    [data-theme="dark"] tr:nth-child(even) {
      background-color: #374151;
    }
    [data-theme="dark"] th, [data-theme="dark"] td {
      border-color: #4b5563;
    }
    [data-theme="dark"] th {
      color: #000000;
    }
    .text-gray-600 {
      color: var(--text-gray-600);
    }
    .text-gray-700 {
      color: var(--text-gray-700);
    }
    .text-gray-500 {
      color: var(--text-gray-500);
    }
    .link-color {
      color: var(--link-color);
    }
    .link-color:hover {
      color: var(--link-hover);
    }
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 60px;
      height: 34px;
    }
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: 0.4s;
      border-radius: 34px;
    }
    .slider:before {
      position: absolute;
      content: "‚òÄÔ∏è";
      height: 26px;
      width: 26px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: 0.4s;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
    }
    input:checked + .slider {
      background-color: #0d9488;
    }
    input:checked + .slider:before {
      content: "üåô";
      transform: translateX(26px);
    }
    [data-theme="dark"] .border-gray-300,
    [data-theme="dark"] .bg-white,
    [data-theme="dark"] pre,
    [data-theme="dark"] #fileName {
      color: #d1d5db;
    }
    [data-theme="dark"] textarea,
    [data-theme="dark"] input[type="text"],
    [data-theme="dark"] input[type="number"] {
      color: #000000;
    }
    #histogramContainer {
      max-width: 100%;
      padding: 2rem;
      background: #fff;
      border: 1px solid #e5e7eb;
      border-radius: 12px;
      margin-bottom: 1.5rem;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    [data-theme="dark"] #histogramContainer {
      background: #374151;
      border-color: #4b5563;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
    }
    #gcHistogramCanvas {
      max-width: 100%;
      height: 400px;
      display: block;
      margin: 0 auto;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
    }
    [data-theme="dark"] #gcHistogramCanvas {
      border-color: #4b5563;
    }
  </style>
</head>
<body>
  <div class="container mx-auto max-w-4xl p-6 rounded-lg shadow-lg">
    <div class="flex justify-between items-center mb-4">
      <h1 class="text-3xl font-bold">FASTA Fragment Tiler</h1>
      <label class="toggle-switch" aria-label="Toggle dark mode">
        <input type="checkbox" id="themeToggle">
        <span class="slider"></span>
      </label>
    </div>
    <button id="toggleInstructions" class="text-indigo-600 font-medium mb-2 hover:underline">Hide Instructions</button>
    <div id="instructions" class="mb-4">
      <p class="text-gray-600 mb-4">
        This tool reads a FASTA file or manually entered sequence, generates fragments of the sequence into overlapping fragments of a specified length and overlap for helping to design gblocks to order. Optionally, it adjusts each overlap to achieve user-specified GC%, avoid long repeats, and outputs the fragments in FASTA format.
      </p>
      <svg id="Layer_1" focusable="false" xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 516.74 131.32">
        <defs>
          <style>
            .st0, .st1 {
              fill: none;
              stroke: var(--svg-text);
              stroke-miterlimit: 10;
            }
            .st2, .st3, .st4 {
              fill: var(--svg-text);
            }
            .st5 {
              fill: #e21f26;
            }
            .st5, .st4 {
              opacity: .2;
            }
            .st3, .st6 {
              font-family: MyriadPro-Regular, 'Myriad Pro';
              font-size: 12px;
            }
            .st7 {
              fill: var(--svg-bg);
            }
            .st6 {
              fill: var(--svg-text-red);
            }
            .st1 {
              stroke-dasharray: 3.74 1.87;
            }
          </style>
        </defs>
        <rect class="st7" width="516.74" height="131.32"/>
        <g>
          <line class="st0" x1="258.37" y1="32.46" x2="258.37" y2="46.48"/>
          <polygon class="st2" points="258.37 50.72 255.93 44.75 258.37 46.16 260.81 44.75 258.37 50.72"/>
        </g>
        <text class="st3" transform="translate(218.89 18.74)"><tspan x="0" y="0">Input Sequence</tspan></text>
        <g>
          <line class="st0" x1="69.39" y1="27.24" x2="443.08" y2="27.24"/>
          <text class="st3" transform="translate(59.47 28.3)"><tspan x="0" y="0">5‚Äô</tspan></text>
          <text class="st3" transform="translate(448.91 28.3)"><tspan x="0" y="0">3‚Äô</tspan></text>
        </g>
        <g>
          <line class="st0" x1="54.77" y1="70.96" x2="174.74" y2="70.96"/>
          <line class="st0" x1="162.33" y1="78.1" x2="279.91" y2="78.1"/>
          <line class="st0" x1="355.58" y1="70.96" x2="389.06" y2="70.96"/>
          <g>
            <line class="st0" x1="318.05" y1="70.96" x2="320.05" y2="70.96"/>
            <line class="st1" x1="321.92" y1="70.96" x2="349.01" y2="70.96"/>
            <line class="st0" x1="349.95" y1="70.96" x2="351.95" y2="70.96"/>
          </g>
          <line class="st0" x1="267.51" y1="70.96" x2="314.66" y2="70.96"/>
          <line class="st0" x1="376.65" y1="78.1" x2="428.46" y2="78.1"/>
          <rect class="st4" x="162.33" y="70.96" width="12.41" height="25.48"/>
          <rect class="st5" x="54.77" y="65.36" width="12.41" height="12.41"/>
          <rect class="st5" x="416.05" y="71.56" width="12.41" height="12.41"/>
          <rect class="st4" x="267.51" y="70.96" width="12.41" height="25.48"/>
          <rect class="st4" x="376.65" y="70.96" width="12.41" height="25.48"/>
          <text class="st3" transform="translate(148.71 109.58)"><tspan x="0" y="0">Overlap</tspan></text>
          <text class="st6" transform="translate(403.94 93.42)"><tspan x="0" y="0">Homology to vector</tspan></text>
          <text class="st6" transform="translate(12.83 90.77)"><tspan x="0" y="0">Homology to vector</tspan></text>
          <text class="st3" transform="translate(256.8 109.58)"><tspan x="0" y="0">Overlap</tspan></text>
          <text class="st3" transform="translate(364.88 109.58)"><tspan x="0" y="0">Overlap</tspan></text>
          <text class="st3" transform="translate(79.84 63.81)"><tspan x="0" y="0">Fragment 1</tspan></text>
          <text class="st3" transform="translate(190.98 63.81)"><tspan x="0" y="0">Fragment 2</tspan></text>
          <text class="st3" transform="translate(302.13 63.81)"><tspan x="0" y="0">Fragment (n-1)</tspan></text>
          <text class="st3" transform="translate(406.5 63.81)"><tspan x="0" y="0">(n)</tspan></text>
          <text class="st3" transform="translate(44.85 74.53)"><tspan x="0" y="0">5‚Äô</tspan></text>
          <text class="st3" transform="translate(434.3 80.75)"><tspan x="0" y="0">3‚Äô</tspan></text>
        </g>
      </svg>
    </div>
    <div class="grid grid-cols-1 gap-4 mb-6">
      <div class="block w-full">
        <div class="flex space-x-4 mb-2">
          <label class="flex items-center">
            <input type="radio" name="inputType" value="file" checked class="mr-2 h-4 w-4 text-indigo-600 focus:ring-teal-500" aria-label="Select FASTA file upload" aria-controls="fileInputContainer">
            <span class="text-gray-700 font-medium">Upload FASTA file</span>
          </label>
          <label class="flex items-center">
            <input type="radio" name="inputType" value="sequence" class="mr-2 h-4 w-4 text-indigo-600 focus:ring-teal-500" aria-label="Select manual sequence input" aria-controls="sequenceInputContainer">
            <span class="text-gray-700 font-medium">Enter sequence manually</span>
          </label>
        </div>
        <div id="fileInputContainer" class="group relative">
          <label class="block w-full">
            <span class="text-gray-700 font-medium">FASTA file:</span>
            <input type="file" id="fastaFile" accept=".fa,.fasta" aria-label="Upload FASTA file" class="mt-1 block w-full border border-gray-300 rounded-md p-2 focus:ring-teal-500 focus:border-teal-500">
            <span id="fileName" class="text-gray-500 text-sm"></span>
            <span id="seqLength" class="text-gray-500 text-sm block"></span>
            <span id="fastaFileError" class="text-red-600 text-sm hidden">Pick a FASTA file first</span>
            <span id="fastaFormatError" class="text-red-600 text-sm hidden">Invalid FASTA format</span>
            <span class="absolute left-0 top-12 mt-1 hidden group-hover:block bg-gray-800 text-white text-xs rounded py-1 px-2 z-10">Upload a FASTA file to fragment</span>
          </label>
        </div>
        <div id="sequenceInputContainer" class="group relative hidden">
          <label class="block w-full">
            <span class="text-gray-700 font-medium">Enter sequence:</span>
            <textarea id="sequenceInput" rows="4" placeholder=">Header&#10;ACTG...&#10;OR&#10;ACTG..." aria-label="Enter sequence manually" class="mt-1 block w-full border border-gray-300 rounded-md p-2 focus:ring-teal-500 focus:border-teal-500"></textarea>
            <span id="seqLengthSequence" class="text-gray-500 text-sm block"></span>
            <span id="sequenceError" class="text-red-600 text-sm hidden">Invalid sequence: use A, C, G, T, N, or FASTA format</span>
            <span class="absolute left-0 top-12 mt-1 hidden group-hover:block bg-gray-800 text-white text-xs rounded py-1 px-2 z-10">Enter a FASTA sequence or plain sequence (A, C, G, T, N)</span>
          </label>
        </div>
      </div>
      <div class="flex flex-col md:flex-row space-x-0 md:space-x-4">
        <label class="block flex-1 group relative">
          <span class="text-gray-700 font-medium">Fragment length:</span>
          <input type="number" id="length" value="1500" min="1" aria-label="Fragment length in bases" class="mt-1 block w-full border border-gray-300 rounded-md p-2 focus:ring-teal-500 focus:border-teal-500">
          <span id="lengthError" class="text-red-600 text-sm hidden">Fragment length must be a positive integer</span>
          <span class="absolute left-0 top-10 mt-1 hidden group-hover:block bg-gray-800 text-white text-xs rounded py-1 px-2 z-10">Desired length of each fragment (bases)</span>
        </label>
        <label class="block flex-1 group relative">
          <span class="text-gray-700 font-medium">Overlap:</span>
          <input type="number" id="overlap" value="25" min="0" aria-label="Overlap between fragments" class="mt-1 block w-full border border-gray-300 rounded-md p-2 focus:ring-teal-500 focus:border-teal-500">
          <span id="overlapError" class="text-red-600 text-sm hidden">Overlap must be a non-negative integer</span>
          <span class="absolute left-0 top-10 mt-1 hidden group-hover:block bg-gray-800 text-white text-xs rounded py-1 px-2 z-10">Bases shared between adjacent fragments</span>
        </label>
      </div>
      <div class="flex flex-col md:flex-row space-x-0 md:space-x-4">
        <label class="block flex-1 group relative">
          <span class="text-gray-700 font-medium">5‚Ä≤ Homology sequence to the vector:</span>
          <input type="text" id="fivePrime" placeholder="AAGGAAGTGCCATTCCGCCTGACCT" aria-label="5‚Ä≤ homology sequence" class="mt-1 block w-full border border-gray-300 rounded-md p-2 focus:ring-teal-500 focus:border-teal-500">
          <span class="absolute left-0 top-10 mt-1 hidden group-hover:block bg-gray-800 text-white text-xs rounded py-1 px-2 z-10">Sequence added to the 5‚Ä≤ end of the first fragment</span>
        </label>
        <label class="block flex-1 group relative">
          <span class="text-gray-700 font-medium">3‚Ä≤ Homology sequence to the vector:</span>
          <input type="text" id="threePrime" placeholder="AGGCTAGGTGGAGGCTCAGTGATGA" aria-label="3‚Ä≤ homology sequence" class="mt-1 block w-full border border-gray-300 rounded-md p-2 focus:ring-teal-500 focus:border-teal-500">
          <span class="absolute left-0 top-10 mt-1 hidden group-hover:block bg-gray-800 text-white text-xs rounded py-1 px-2 z-10">Sequence added to the 3‚Ä≤ end of the last fragment</span>
        </label>
      </div>
      <label class="block w-full flex items-center group relative">
        <input type="checkbox" id="gcBalance" class="mr-2 h-4 w-4 text-indigo-600 focus:ring-teal-500 border-gray-300 rounded" aria-label="Enforce GC% constraints">
        <span class="text-gray-700 font-medium">Enforce GC% & no 4+ mono/di/tri‚Äêrepeats in overlaps</span>
        <span class="absolute left-0 top-10 mt-1 hidden group-hover:block bg-gray-800 text-white text-xs rounded py-1 px-2 z-10">Adjust overlaps to meet GC% and avoid long repeats</span>
      </label>
      <div class="flex flex-col md:flex-row space-x-0 md:space-x-4">
        <label class="block flex-1 group relative">
          <span class="text-gray-700 font-medium">Minimum GC%:</span>
          <input type="number" id="gcMin" value="35" min="0" max="100" placeholder="35" aria-label="Minimum GC percentage" class="mt-1 block w-full border border-gray-300 rounded-md p-2 focus:ring-teal-500 focus:border-teal-500">
          <span id="gcMinError" class="text-red-600 text-sm hidden">Minimum GC% must be between 0 and 100</span>
          <span class="absolute left-0 top-10 mt-1 hidden group-hover:block bg-gray-800 text-white text-xs rounded py-1 px-2 z-10">Minimum GC content for overlaps (%)</span>
        </label>
        <label class="block flex-1 group relative">
          <span class="text-gray-700 font-medium">Maximum GC%:</span>
          <input type="number" id="gcMax" value="60" min="0" max="100" placeholder="60" aria-label="Maximum GC percentage" class="mt-1 block w-full border border-gray-300 rounded-md p-2 focus:ring-teal-500 focus:border-teal-500">
          <span id="gcMaxError" class="text-red-600 text-sm hidden">Maximum GC% must be between 0 and 100</span>
          <span class="absolute left-0 top-10 mt-1 hidden group-hover:block bg-gray-800 text-white text-xs rounded py-1 px-2 z-10">Maximum GC content for overlaps (%)</span>
        </label>
      </div>
      <label class="block w-full flex items-center group relative">
        <input type="checkbox" id="showHistogram" class="mr-2 h-4 w-4 text-indigo-600 focus:ring-teal-500 border-gray-300 rounded" aria-label="Show GC% histogram">
        <span class="text-gray-700 font-medium">Show GC% Histogram</span>
        <span class="absolute left-0 top-10 mt-1 hidden group-hover:block bg-gray-800 text-white text-xs rounded py-1 px-2 z-10">Display a bar chart of GC% distribution</span>
      </label>
    </div>
    <button id="processBtn" role="button" aria-label="Process FASTA file or sequence" class="w-full bg-indigo-600 text-white font-semibold py-2 px-4 rounded-md hover:bg-teal-600 transition duration-200 disabled:opacity-50">Process</button>
    <h2 class="text-2xl font-semibold mt-6 mb-4">Output</h2>
    <div id="progress" class="hidden text-center mb-4"><div class="inline-block animate-spin rounded-full h-8 w-8 border-t-2 border-teal-600"></div></div>
    <span id="fragCount" class="text-gray-500 text-sm block mb-2"></span>
    <table id="fragTable" class="hidden mb-4">
      <thead>
        <tr class="bg-gray-100">
          <th class="border p-2">Fragment</th>
          <th class="border p-2">Start</th>
          <th class="border p-2">End</th>
          <th class="border p-2">Length</th>
          <th class="border p-2">GC%</th>
        </tr>
      </thead>
      <tbody id="fragTableBody"></tbody>
    </table>
    <div id="histogramContainer" class="hidden mb-4">
      <canvas id="gcHistogramCanvas"></canvas>
    </div>
    <div class="flex space-x-2 mb-4">
      <button id="downloadBtn" role="button" aria-label="Download FASTA output" class="bg-indigo-600 text-white font-semibold py-2 px-4 rounded-md hover:bg-teal-600 transition duration-200 hidden">Download FASTA</button>
      <button id="copyBtn" role="button" aria-label="Copy FASTA output to clipboard" class="bg-indigo-600 text-white font-semibold py-2 px-4 rounded-md hover:bg-teal-600 transition duration-200 hidden">Copy to Clipboard</button>
    </div>
    <pre id="outLog" class="border border-gray-200 rounded-md p-4 text-sm"></pre>
  </div>
  <footer>
    <p class="text-gray-600">Created by <a href="https://github.com/mbuyukyoruk" class="link-color" target="_blank" rel="noopener noreferrer">Murat Buyukyoruk</a></p>
  </footer>
<script>
/**
 * Robust FASTA parser: splits on leading ">", then first line is header,
 * subsequent lines are sequence. Also handles single-line entries and plain sequences.
 */
function parseFasta(text) {
  text = text.trim();
  const recs = [];
  let seqLength = 0;
  if (text.startsWith(">")) {
    const entries = text.split(/^>/m);
    for (let entry of entries) {
      entry = entry.trim();
      if (!entry) continue;
      const lines = entry.split(/[\r\n]+/);
      const headerLine = lines[0].trim();
      const id = headerLine.split(/\s+/)[0] || "UserInput";
      let seq = "";
      if (lines.length > 1) {
        seq = lines.slice(1).join("").replace(/\s/g, "").toUpperCase();
      } else {
        const parts = entry.split(/\s+/);
        if (parts.length > 1) {
          seq = parts.slice(1).join("").toUpperCase();
        }
      }
      if (seq && /^[ACGTNacgtn]+$/.test(seq)) {
        recs.push({id, seq});
        seqLength = seq.length;
      }
    }
  } else if (/^[ACGTNacgtn]+$/.test(text.replace(/\s/g, ""))) {
    const seq = text.replace(/\s/g, "").toUpperCase();
    recs.push({id: "UserInput", seq});
    seqLength = seq.length;
  }
  const seqLengthEl = document.querySelector(document.querySelector('input[name="inputType"]:checked').value === "file" ? "#seqLength" : "#seqLengthSequence");
  seqLengthEl.textContent = seqLength ? `Sequence length: ${seqLength} bases` : "";
  return recs;
}
/**
 * Validate FASTA or sequence text
 */
function isValidFastaOrSequence(text) {
  text = text.trim();
  if (text.startsWith(">")) {
    return /^>.*[\r\n]+[ACGTNacgtn]+/m.test(text);
  }
  return /^[ACGTNacgtn\s]+$/.test(text);
}
function gcContent(s) {
  let gc = 0;
  s = s.toUpperCase();
  for (let c of s) if (c === 'G' || c === 'C') gc++;
  return s.length ? gc / s.length : 0;
}
function hasBadRepeats(s) {
  s = s.toUpperCase();
  if (/(A|C|G|T)\1{3,}/.test(s)) return true;
  if (/([ACGT]{2})\1{3,}/.test(s)) return true;
  if (/([ACGT]{3})\1{3,}/.test(s)) return true;
  return false;
}
/**
 * Slide overlap backward and forward to find GC% in [min, max] and no bad repeats.
 */
function adjustOverlap(seq, ideal, overlap, minGC, maxGC) {
  let bestPos = ideal;
  let bestGC = gcContent(seq.substr(ideal, overlap));
  let minGCDiff = Math.min(Math.abs(bestGC - minGC), Math.abs(bestGC - maxGC));
  const searchRange = 300;
  let validPos = null;
  for (let pos = ideal; pos >= Math.max(0, ideal - searchRange); pos--) {
    const w = seq.substr(pos, overlap);
    const gc = gcContent(w);
    if (gc >= minGC && gc <= maxGC && !hasBadRepeats(w)) {
      validPos = pos;
      break;
    }
    const diff = Math.min(Math.abs(gc - minGC), Math.abs(gc - maxGC));
    if (diff < minGCDiff) {
      minGCDiff = diff;
      bestPos = pos;
      bestGC = gc;
    }
  }
  if (!validPos) {
    for (let pos = ideal + 1; pos <= Math.min(seq.length - overlap, ideal + searchRange); pos++) {
      const w = seq.substr(pos, overlap);
      const gc = gcContent(w);
      if (gc >= minGC && gc <= maxGC && !hasBadRepeats(w)) {
        validPos = pos;
        break;
      }
      const diff = Math.min(Math.abs(gc - minGC), Math.abs(gc - maxGC));
      if (diff < minGCDiff) {
        minGCDiff = diff;
        bestPos = pos;
        bestGC = gc;
      }
    }
  }
  if (validPos !== null) {
    return validPos;
  }
  console.warn(`No valid overlap found with GC ${minGC*100}‚Äì${maxGC*100}% at position ${ideal}; trying relaxed GC 30‚Äì60%`);
  const relaxedMinGC = 0.30;
  for (let pos = ideal; pos >= Math.max(0, ideal - searchRange); pos--) {
    const w = seq.substr(pos, overlap);
    const gc = gcContent(w);
    if (gc >= relaxedMinGC && gc <= maxGC && !hasBadRepeats(w)) {
      console.warn(`Using relaxed GC at pos ${pos} with GC ${(gc*100).toFixed(2)}%`);
      return pos;
    }
  }
  for (let pos = ideal + 1; pos <= Math.min(seq.length - overlap, ideal + searchRange); pos++) {
    const w = seq.substr(pos, overlap);
    const gc = gcContent(w);
    if (gc >= relaxedMinGC && gc <= maxGC && !hasBadRepeats(w)) {
      console.warn(`Using relaxed GC at pos ${pos} with GC ${(gc*100).toFixed(2)}%`);
      return pos;
    }
  }
  console.warn(`No valid overlap found even with relaxed GC 30‚Äì60% at position ${ideal}; using pos ${bestPos} with GC ${(bestGC*100).toFixed(2)}%`);
  return bestPos;
}
/**
 * Generate sequence fragments
 */
function fragmentSequence(seq, L, O, fivePrime, threePrime) {
  const frags = [];
  let pos = 0;
  const hasAdapters = fivePrime || threePrime;
  if (!hasAdapters) {
    frags.push({ start: 0, end: Math.min(L, seq.length) });
    pos = L - O;
  } else {
    const firstLen = L - O;
    frags.push({ start: 0, end: Math.min(firstLen, seq.length) });
    pos = firstLen - O;
  }
  while (pos + L < seq.length) {
    frags.push({ start: pos, end: Math.min(pos + L, seq.length) });
    pos = pos + L - O;
  }
  if (pos < seq.length) {
    frags.push({ start: pos, end: seq.length });
  }
  return frags;
}
/**
 * Re-split oversized fragments and merge short fragments
 */
function resplitFragments(frags, L, O, seqLength) {
  const newFrags = [];
  let i = 0;
  while (i < frags.length) {
    let { start, end } = frags[i];
    if (i < frags.length - 1 && end - start > L) {
      let pos = start;
      while (pos + L < end) {
        newFrags.push({ start: pos, end: Math.min(pos + L, seqLength) });
        pos += L - O;
      }
      if (pos < end) {
        newFrags.push({ start: pos, end });
      }
      i++;
    } else if (i < frags.length - 1 && end - start < 1000 && i + 1 < frags.length) {
      const next = frags[i + 1];
      const combinedLen = next.end - start;
      if (combinedLen <= L + O) {
        newFrags.push({ start, end: next.end });
        i += 2;
      } else {
        newFrags.push({ start, end });
        i++;
      }
    } else {
      newFrags.push({ start, end });
      i++;
    }
  }
  if (newFrags.length > 1 && newFrags[newFrags.length - 1].end - newFrags[newFrags.length - 1].start < 1000) {
    const last = newFrags.pop();
    const prev = newFrags[newFrags.length - 1];
    if (last.end - prev.start <= L + O) {
      prev.end = last.end;
    } else {
      newFrags.push(last);
    }
  }
  return newFrags;
}
/**
 * Save input values to localStorage
 */
function saveInputs() {
  const inputs = ["length", "overlap", "fivePrime", "threePrime", "gcMin", "gcMax", "gcBalance", "showHistogram"];
  inputs.forEach(id => {
    const el = document.getElementById(id);
    localStorage.setItem(id, el.type === "checkbox" ? el.checked : el.value);
  });
}
/**
 * Load input values from localStorage
 */
function loadInputs() {
  const inputs = [
    { id: "length", default: "1500" },
    { id: "overlap", default: "25" },
    { id: "fivePrime", default: "" },
    { id: "threePrime", default: "" },
    { id: "gcMin", default: "35" },
    { id: "gcMax", default: "60" },
    { id: "gcBalance", default: false, type: "checkbox" },
    { id: "showHistogram", default: false, type: "checkbox" }
  ];
  inputs.forEach(({ id, default: def, type }) => {
    const value = localStorage.getItem(id);
    const el = document.getElementById(id);
    if (value !== null) {
      el[type === "checkbox" ? "checked" : "value"] = type === "checkbox" ? value === "true" : value;
    } else {
      el[type === "checkbox" ? "checked" : "value"] = def;
    }
  });
  toggleGCFields();
}
/**
 * Clear output elements
 */
function clearOutput() {
  document.getElementById("outLog").textContent = "";
  document.getElementById("downloadBtn").style.display = "none";
  document.getElementById("copyBtn").style.display = "none";
  document.getElementById("fragTable").classList.add("hidden");
  document.getElementById("fragCount").textContent = "";
  document.getElementById("histogramContainer").classList.add("hidden");
  const canvas = document.getElementById("gcHistogramCanvas");
  if (canvas) canvas.getContext("2d").clearRect(0, 0, canvas.width, canvas.height);
}
/**
 * Draw GC% histogram with animation
 */
function drawHistogram(gcValues) {
  const canvas = document.getElementById("gcHistogramCanvas");
  const ctx = canvas.getContext("2d");
  // Set canvas dimensions
  canvas.width = canvas.parentElement.offsetWidth * 0.95;
  canvas.height = 400;
  // Define margins
  const margin = { top: 60, right: 30, bottom: 80, left: 60 };
  const plotWidth = canvas.width - margin.left - margin.right;
  const plotHeight = canvas.height - margin.top - margin.bottom;
  // Calculate bar width and spacing
  const barWidth = Math.min(40, plotWidth / gcValues.length * 0.8);
  const barSpacing = (plotWidth - barWidth * gcValues.length) / (gcValues.length + 1);
  // Get GC range for scaling
  const maxGC = Math.ceil(Math.max(...gcValues.map(v => v * 100)) / 10) * 10 || 100;
  const minGC = Math.floor(Math.min(...gcValues.map(v => v * 100)) / 10) * 10 || 0;
  const gcRange = maxGC - minGC;
  const barHeightScale = plotHeight / gcRange;
  // Animation setup
  let animationProgress = 0;
  const animationDuration = 500; // ms
  const draw = (progress, hoverIndex = -1) => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    // Draw background
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    // Draw grid lines
    ctx.strokeStyle = `var(--histogram-grid)`;
    ctx.lineWidth = 0.5;
    for (let gc = minGC; gc <= maxGC; gc += 10) {
      const y = margin.top + plotHeight - ((gc - minGC) * barHeightScale);
      ctx.beginPath();
      ctx.moveTo(margin.left, y);
      ctx.lineTo(margin.left + plotWidth, y);
      ctx.stroke();
    }
    // Draw axes
    ctx.beginPath();
    ctx.moveTo(margin.left, margin.top);
    ctx.lineTo(margin.left, margin.top + plotHeight);
    ctx.lineTo(margin.left + plotWidth, margin.top + plotHeight);
    ctx.strokeStyle = "#000000";
    ctx.lineWidth = 1;
    ctx.stroke();
    // Draw y-axis labels
    ctx.font = "14px Inter";
    ctx.fillStyle = "#000000";
    ctx.textAlign = "right";
    ctx.textBaseline = "middle";
    for (let gc = minGC; gc <= maxGC; gc += 10) {
      const y = margin.top + plotHeight - ((gc - minGC) * barHeightScale);
      ctx.fillText(`${gc}%`, margin.left - 15, y);
    }
    // Draw x-axis labels
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    gcValues.forEach((gc, i) => {
      const x = margin.left + barSpacing * (i + 1) + barWidth * i + barWidth / 2;
      ctx.fillText(`Frag ${i + 1}`, x, margin.top + plotHeight + 20);
    });
    // Draw bars with animation
    gcValues.forEach((gc, i) => {
      const height = (gc * 100 - minGC) * barHeightScale * progress;
      const x = margin.left + barSpacing * (i + 1) + barWidth * i;
      const y = margin.top + plotHeight - height;
      ctx.fillStyle = i === hoverIndex ? "rgba(13,148,136,0.9)" : "rgba(20,184,166,0.9)";
      ctx.shadowColor = "rgba(0,0,0,0.2)";
      ctx.shadowBlur = i === hoverIndex ? 6 : 4;
      ctx.beginPath();
      ctx.moveTo(x + 6, y);
      ctx.arcTo(x, y, x, y + 6, 6);
      ctx.lineTo(x, y + height - 6);
      ctx.arcTo(x, y + height, x + 6, y + height, 6);
      ctx.lineTo(x + barWidth - 6, y + height);
      ctx.arcTo(x + barWidth, y + height, x + barWidth, y + height - 6, 6);
      ctx.lineTo(x + barWidth, y + 6);
      ctx.arcTo(x + barWidth, y, x + barWidth - 6, y, 6);
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;
      // Draw GC% label (always black)
      ctx.fillStyle = "#000000";
      ctx.fillText(`${(gc * 100).toFixed(1)}%`, x + barWidth / 2, y - 20);
    });
    // Draw title
    ctx.font = "20px Inter";
    ctx.fillStyle = "#000000";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    ctx.fillText("GC Content Distribution", canvas.width / 2, margin.top / 2 - 20);
    // Draw axis labels
    ctx.font = "16px Inter";
    ctx.fillText("Fragment", canvas.width / 2, canvas.height - 25);
    ctx.save();
    ctx.translate(margin.left / 2 - 20, canvas.height / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText("GC Content (%)", 0, 0);
    ctx.restore();
  };
  // Animation loop
  const startTime = performance.now();
  const animate = (time) => {
    animationProgress = Math.min((time - startTime) / animationDuration, 1);
    draw(animationProgress);
    if (animationProgress < 1) {
      requestAnimationFrame(animate);
    }
  };
  requestAnimationFrame(animate);
  // Hover effect
  canvas.onmousemove = (e) => {
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    let hoverIndex = -1;
    gcValues.forEach((gc, i) => {
      const x = margin.left + barSpacing * (i + 1) + barWidth * i;
      const height = (gc * 100 - minGC) * barHeightScale;
      const y = margin.top + plotHeight - height;
      // Check if mouse is within bar bounds
      if (mouseX >= x && mouseX <= x + barWidth && mouseY >= y && mouseY <= margin.top + plotHeight) {
        hoverIndex = i;
      }
    });
    // Redraw with hover
    draw(1, hoverIndex);
    canvas.style.cursor = hoverIndex >= 0 ? "pointer" : "default";
  };
  canvas.onmouseout = () => {
    draw(1);
    canvas.style.cursor = "default";
  };
  console.log("Histogram drawn with GC values:", gcValues.map(v => (v * 100).toFixed(1) + "%"));
}
document.getElementById("processBtn").onclick = async () => {
  const btn = document.getElementById("processBtn");
  btn.disabled = true;
  btn.textContent = "Processing...";
  document.getElementById("progress").classList.remove("hidden");
  const fastaError = document.getElementById("fastaFileError");
  const fastaFormatError = document.getElementById("fastaFormatError");
  const sequenceError = document.getElementById("sequenceError");
  const lengthError = document.getElementById("lengthError");
  const overlapError = document.getElementById("overlapError");
  const gcMinError = document.getElementById("gcMinError");
  const gcMaxError = document.getElementById("gcMaxError");
  // Reset errors
  fastaError.classList.add("hidden");
  fastaFormatError.classList.add("hidden");
  sequenceError.classList.add("hidden");
  lengthError.classList.add("hidden");
  overlapError.classList.add("hidden");
  gcMinError.classList.add("hidden");
  gcMaxError.classList.add("hidden");
  const inputType = document.querySelector('input[name="inputType"]:checked').value;
  let text = "";
  let file = null;
  if (inputType === "file") {
    file = document.getElementById("fastaFile").files[0];
    if (!file) {
      fastaError.classList.remove("hidden");
      btn.disabled = false;
      btn.textContent = "Process";
      document.getElementById("progress").classList.add("hidden");
      return;
    }
    text = await file.text();
    if (!isValidFastaOrSequence(text)) {
      fastaFormatError.classList.remove("hidden");
      btn.disabled = false;
      btn.textContent = "Process";
      document.getElementById("progress").classList.add("hidden");
      return;
    }
  } else {
    text = document.getElementById("sequenceInput").value.trim();
    if (!text || !isValidFastaOrSequence(text)) {
      sequenceError.classList.remove("hidden");
      btn.disabled = false;
      btn.textContent = "Process";
      document.getElementById("progress").classList.add("hidden");
      return;
    }
  }
  const L = +document.getElementById("length").value;
  const O = +document.getElementById("overlap").value;
  const five = document.getElementById("fivePrime").value.trim();
  const three = document.getElementById("threePrime").value.trim();
  const doGC = document.getElementById("gcBalance").checked;
  const gcMin = parseFloat(document.getElementById("gcMin").value) / 100;
  const gcMax = parseFloat(document.getElementById("gcMax").value) / 100;
  const showHistogram = document.getElementById("showHistogram").checked;
  // Validate inputs
  if (isNaN(L) || L < 1) {
    lengthError.classList.remove("hidden");
    btn.disabled = false;
    btn.textContent = "Process";
    document.getElementById("progress").classList.add("hidden");
    return;
  }
  if (isNaN(O) || O < 0) {
    overlapError.classList.remove("hidden");
    btn.disabled = false;
    btn.textContent = "Process";
    document.getElementById("progress").classList.add("hidden");
    return;
  }
  if (doGC) {
    if (isNaN(gcMin) || gcMin < 0 || gcMin > 1) {
      gcMinError.classList.remove("hidden");
      btn.disabled = false;
      btn.textContent = "Process";
      document.getElementById("progress").classList.add("hidden");
      return;
    }
    if (isNaN(gcMax) || gcMax < 0 || gcMax > 1) {
      gcMaxError.classList.remove("hidden");
      btn.disabled = false;
      btn.textContent = "Process";
      document.getElementById("progress").classList.add("hidden");
      return;
    }
    if (gcMin > gcMax) {
      gcMaxError.textContent = "Minimum GC% must be less than or equal to Maximum GC%";
      gcMaxError.classList.remove("hidden");
      btn.disabled = false;
      btn.textContent = "Process";
      document.getElementById("progress").classList.add("hidden");
      return;
    }
  }
  const records = parseFasta(text);
  if (records.length === 0) {
    sequenceError.classList.remove("hidden");
    sequenceError.textContent = "No valid sequences found";
    btn.disabled = false;
    btn.textContent = "Process";
    document.getElementById("progress").classList.add("hidden");
    return;
  }
  window.GC_MIN = doGC ? gcMin : 0.35;
  window.GC_MAX = doGC ? gcMax : 0.60;
  let out = "";
  for (let rec of records) {
    let frags = fragmentSequence(rec.seq, L, O, five, three);
    if (doGC) {
      // First GC pass
      for (let j = 0; j < frags.length - 1; j++) {
        const cur = frags[j], nxt = frags[j+1];
        const ideal = cur.end - O;
        const best = adjustOverlap(rec.seq, ideal, O, window.GC_MIN, window.GC_MAX);
        cur.end = best + O;
        nxt.start = best;
        if (j + 1 < frags.length - 1) {
          nxt.end = Math.min(best + L, rec.seq.length);
        }
        for (let k = j + 1; k < frags.length - 1; k++) {
          frags[k].start = frags[k-1].end - O;
          frags[k].end = Math.min(frags[k].start + L, rec.seq.length);
        }
        if (nxt.end - nxt.start < O && j + 1 < frags.length - 1) {
          console.warn(`Fragment ${j+2} too short (${nxt.end - nxt.start} bases); adjusting...`);
          nxt.end = Math.min(nxt.start + L, rec.seq.length);
        }
        const overlapSeq = rec.seq.slice(best, best + O);
        const gc = gcContent(overlapSeq);
        if (gc < window.GC_MIN || gc > window.GC_MAX || hasBadRepeats(overlapSeq)) {
          console.warn(`Overlap ${j+1} at ${best}-${best+O} has GC ${(gc*100).toFixed(2)}% or bad repeats: ${overlapSeq}`);
        }
      }
      frags = resplitFragments(frags, L, O, rec.seq.length);
      // Second GC pass
      for (let j = 0; j < frags.length - 1; j++) {
        const cur = frags[j], nxt = frags[j+1];
        const ideal = cur.end - O;
        const best = adjustOverlap(rec.seq, ideal, O, window.GC_MIN, window.GC_MAX);
        cur.end = best + O;
        nxt.start = best;
        if (j + 1 < frags.length - 1) {
          nxt.end = Math.min(best + L, rec.seq.length);
        }
        const overlapSeq = rec.seq.slice(best, best + O);
        const gc = gcContent(overlapSeq);
        if (gc < window.GC_MIN || gc > window.GC_MAX || hasBadRepeats(overlapSeq)) {
          console.warn(`Overlap ${j+1} at ${best}-${best+O} has GC ${(gc*100).toFixed(2)}% or bad repeats: ${overlapSeq}`);
        }
      }
      frags = resplitFragments(frags, L, O, rec.seq.length);
    }
    frags = frags.filter((frag, i) => {
      if (i === 0 || i === frags.length - 1) return true;
      const len = frag.end - frag.start;
      if (len < O) {
        console.warn(`Removing fragment ${i+1} with length ${len} (less than overlap ${O})`);
        return false;
      }
      return true;
    });
    // Populate fragment table
    const tableBody = document.getElementById("fragTableBody");
    tableBody.innerHTML = "";
    const gcValues = [];
    frags.forEach((frag, i) => {
      const gc = doGC ? (gcContent(rec.seq.slice(frag.start, frag.end)) * 100).toFixed(2) : "N/A";
      gcValues.push(doGC ? gcContent(rec.seq.slice(frag.start, frag.end)) : 0);
      tableBody.insertAdjacentHTML("beforeend", `<tr><td class="border p-2">${rec.id}_${frag.start+1}_${frag.end}</td><td class="border p-2">${frag.start+1}</td><td class="border p-2">${frag.end}</td><td class="border p-2">${frag.end - frag.start}</td><td class="border p-2">${gc}</td></tr>`);
    });
    document.getElementById("fragTable").classList.remove("hidden");
    document.getElementById("fragCount").textContent = `Generated ${frags.length} fragments`;
    // Show histogram if requested and GC balancing is enabled
    if (showHistogram && doGC) {
      document.getElementById("histogramContainer").classList.remove("hidden");
      drawHistogram(gcValues);
    } else {
      document.getElementById("histogramContainer").classList.add("hidden");
    }
    // Output fragments
    for (let i = 0; i < frags.length; i++) {
      let {start, end} = frags[i];
      let seqFrag = rec.seq.slice(start, end);
      if (i === 0 && five) seqFrag = five + seqFrag;
      if (i === frags.length - 1 && three) seqFrag += three;
      out += `>${rec.id}_${start+1}_${end}\n`;
      for (let k = 0; k < seqFrag.length; k += 90) {
        out += seqFrag.substr(k, 90) + "\n";
      }
    }
  }
  document.getElementById("outLog").textContent = out;
  const blob = new Blob([out], {type: 'text/plain'});
  const url = URL.createObjectURL(blob);
  const downloadBtn = document.getElementById("downloadBtn");
  const copyBtn = document.getElementById("copyBtn");
  downloadBtn.style.display = 'inline-block';
  copyBtn.style.display = 'inline-block';
  downloadBtn.onclick = () => {
    const prefix = prompt("Enter a prefix for the downloaded file (optional):", "user_input");
    const filePrefix = prefix ? prefix : "user_input";
    const a = document.createElement('a');
    a.href = url;
    a.download = `${filePrefix}_fragments.fa`;
    a.click();
  };
  copyBtn.onclick = () => {
    navigator.clipboard.writeText(out).then(() => alert("Output copied to clipboard!"));
  };
  btn.disabled = false;
  btn.textContent = "Process";
  document.getElementById("progress").classList.add("hidden");
};
document.getElementById("fastaFile").addEventListener("change", () => {
  const file = document.getElementById("fastaFile").files[0];
  document.getElementById("fileName").textContent = file ? `Selected: ${file.name}` : "";
  clearOutput();
  if (file) {
    file.text().then(parseFasta);
  } else {
    document.getElementById("seqLength").textContent = "";
  }
});
document.getElementById("sequenceInput").addEventListener("input", () => {
  clearOutput();
  const text = document.getElementById("sequenceInput").value.trim();
  if (text) parseFasta(text);
});
const inputTypeRadios = document.querySelectorAll('input[name="inputType"]');
const fileInputContainer = document.getElementById("fileInputContainer");
const sequenceInputContainer = document.getElementById("sequenceInputContainer");
function toggleInputFields() {
  const inputType = document.querySelector('input[name="inputType"]:checked').value;
  if (inputType === "file") {
    fileInputContainer.classList.remove("hidden");
    sequenceInputContainer.classList.add("hidden");
    document.getElementById("sequenceInput").value = "";
    document.getElementById("seqLengthSequence").textContent = "";
  } else {
    fileInputContainer.classList.add("hidden");
    sequenceInputContainer.classList.remove("hidden");
    document.getElementById("fastaFile").value = "";
    document.getElementById("fileName").textContent = "";
    document.getElementById("seqLength").textContent = "";
  }
  clearOutput();
}
inputTypeRadios.forEach(radio => {
  radio.addEventListener("change", toggleInputFields);
});
toggleInputFields();
const checkbox = document.getElementById("gcBalance");
const gcMinLabel = document.getElementById("gcMin").parentElement;
const gcMaxLabel = document.getElementById("gcMax").parentElement;
const gcMinInput = document.getElementById("gcMin");
const gcMaxInput = document.getElementById("gcMax");
function toggleGCFields() {
  if (checkbox.checked) {
    gcMinLabel.style.display = "block";
    gcMaxLabel.style.display = "block";
    gcMinInput.disabled = false;
    gcMaxInput.disabled = false;
  } else {
    gcMinLabel.style.display = "none";
    gcMaxLabel.style.display = "none";
    gcMinInput.disabled = true;
    gcMaxInput.disabled = true;
  }
}
toggleGCFields();
checkbox.addEventListener("change", () => {
  toggleGCFields();
  saveInputs();
});
document.getElementById("toggleInstructions").onclick = () => {
  const div = document.getElementById("instructions");
  const btn = document.getElementById("toggleInstructions");
  div.classList.toggle("hidden");
  btn.textContent = div.classList.contains("hidden") ? "Show Instructions" : "Hide Instructions";
};
document.getElementById("themeToggle").addEventListener("change", () => {
  document.documentElement.dataset.theme = document.getElementById("themeToggle").checked ? "dark" : "light";
  localStorage.setItem("theme", document.documentElement.dataset.theme);
});
if (localStorage.getItem("theme") === "dark") {
  document.documentElement.dataset.theme = "dark";
  document.getElementById("themeToggle").checked = true;
}
document.querySelectorAll("#length, #overlap, #fivePrime, #threePrime, #gcMin, #gcMax, #gcBalance, #showHistogram").forEach(el => {
  el.addEventListener(el.type === "checkbox" ? "change" : "input", saveInputs);
});
loadInputs();
</script>
</body>
</html>