<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FASTA Fragment Tiler</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700;800&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-gradient: linear-gradient(to bottom, #f3f4f6, #14b8a6);
      --bg-container: #ffffff;
      --text-color: #374151;
      --svg-bg: #ffffff;
      --svg-text: #231f20;
      --svg-text-red: #ba2025;
      --output-bg: #f9fafb;
      --text-gray-600: #4b5563;
      --text-gray-700: #374151;
      --text-gray-500: #6b7280;
      --link-color: #4f46e5;
      --link-hover: #0d9488;
      --histogram-bar: #14b8a6;
      --histogram-bar-hover: #0d9488;
      --histogram-grid: #d1d5db;
    }
    [data-theme="dark"] {
      --bg-gradient: linear-gradient(to bottom, #1f2937, #065f46);
      --bg-container: #1f2937;
      --text-color: #e5e7eb;
      --svg-bg: #1f2937;
      --svg-text: #f3f4f6;
      --svg-text-red: #f87171;
      --output-bg: #ffffff;
      --text-gray-600: #d1d5db;
      --text-gray-700: #e5e7eb;
      --text-gray-500: #9ca3af;
      --link-color: #5eead4;
      --link-hover: #99f6e4;
      --histogram-grid: #4b5563;
    }
    body {
      background: var(--bg-gradient);
      font-family: 'Inter', sans-serif;
      color: var(--text-color);
      min-height: 100vh;
      margin: 0;
      padding: 0;
      position: relative;
    }
    .container {
      background: var(--bg-container);
      position: relative;
      min-height: 100vh;
    }
    pre {
      white-space: pre-wrap;
      overflow-x: auto;
      max-height: 400px;
      background: var(--output-bg);
      color: #000000;
    }
    #outLog {
      color: #000000;
    }
    [data-theme="dark"] #outLog {
      color: #000000;
    }
    svg {
      display: block;
      margin: 1.5rem auto;
      width: 100%;
      max-width: 100%;
      height: auto;
    }
    p {
      font-size: 1.1rem;
      line-height: 1.6;
    }
    .st3, .st6 {
      font-size: 12px;
    }
    .st7 {
      fill: var(--svg-bg);
    }
    .st3, .st4 {
      fill: var(--svg-text);
    }
    .st6 {
      fill: var(--svg-text-red);
    }
    .st0, .st1 {
      fill: none;
      stroke: var(--svg-text);
      stroke-miterlimit: 10;
    }
    .st2 {
      fill: var(--svg-text);
    }
    .st1 {
      stroke-dasharray: 3.74 1.87;
    }
    footer {
      text-align: center;
      padding: 1rem 0;
    }
        /* Updated table styles */
    .table-container {
      width: 100%;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
      margin-bottom: 1.5rem;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.95rem; /* Slightly smaller font for tables */
    }
    th, td {
      border: 1px solid #e5e7eb;
      padding: 6px;
      text-align: left;
       white-space: nowrap; /* Prevent text wrapping */
    }
    th {
      background-color: #f3f4f6;
      font-weight: 600;
    }
    tr:nth-child(even) {
      background-color: #f9fafb;
    }
    tr:hover {
      background-color: #e5e7eb;
    }
    [data-theme="dark"] tr:nth-child(even) {
      background-color: #374151;
    }
    [data-theme="dark"] tr:hover {
      background-color: #4b5563;
    }
    [data-theme="dark"] th, [data-theme="dark"] td {
      border-color: #4b5563;
    }
    [data-theme="dark"] th {
      background-color: #2d3748;
      color: #e5e7eb;
    }
    /* Sequence column specific styling */
    td.font-mono {
      font-family: 'Courier New', Courier, monospace;
      font-size: 0.85rem;
      max-width: 150px; /* Limit width to avoid excessive stretching */
      overflow: hidden;
      text-overflow: ellipsis;
    }
    /* Mobile-specific styles */
    @media (max-width: 640px) {
      table {
        font-size: 0.8rem; /* Smaller font on mobile */
      }
      th, td {
        padding: 4px; /* Further reduced padding */
      }
      td.font-mono {
        font-size: 0.75rem;
        max-width: 100px; /* Tighter max-width on mobile */
      }
      .table-container {
        padding-right: 0;
        padding-left: 0;
      }
      #histogramContainer {
        padding: 1rem; /* Reduced padding on mobile */
      }
    }
    .text-gray-600 {
      color: var(--text-gray-600);
    }
    .text-gray-700 {
      color: var(--text-gray-700);
    }
    .text-gray-500 {
      color: var(--text-gray-500);
    }
    .link-color {
      color: var(--link-color);
    }
    .link-color:hover {
      color: var(--link-hover);
    }
    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 60px;
      height: 34px;
    }
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: 0.4s;
      border-radius: 34px;
    }
    .slider:before {
      position: absolute;
      content: "‚òÄÔ∏è";
      height: 26px;
      width: 26px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: 0.4s;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
    }
    input:checked + .slider {
      background-color: #0d9488;
    }
    input:checked + .slider:before {
      content: "üåô";
      transform: translateX(26px);
    }
    [data-theme="dark"] .border-gray-300,
    [data-theme="dark"] .bg-white,
    [data-theme="dark"] pre,
    [data-theme="dark"] #fileName {
      color: #d1d5db;
    }
    [data-theme="dark"] textarea,
    [data-theme="dark"] input[type="text"],
    [data-theme="dark"] input[type="number"],
    [data-theme="dark"] #sequenceInput {
      color: #000000;
    }
    #histogramContainer {
      max-width: 100%;
      padding: 2rem;
      background: #fff;
      border: 1px solid #e5e7eb;
      border-radius: 12px;
      margin-bottom: 1.5rem;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    [data-theme="dark"] #histogramContainer {
      background: #374151;
      border-color: #4b5563;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
    }
    #gcHistogramCanvas {
      max-width: 100%;
      display: block;
      margin: 0 auto;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
    }
    [data-theme="dark"] #gcHistogramCanvas {
      border-color: #4b5563;
    }
    #overlapTableContainer {
      max-width: 100%;
      padding: 2rem;
      background: #fff;
      border: 1px solid #e5e7eb;
      border-radius: 12px;
      margin-bottom: 1.5rem;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    [data-theme="dark"] #overlapTableContainer {
      background: #374151;
      border-color: #4b5563;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
    }
    .input-error {
      border-color: #ef4444 !important;
    }
    .tooltip {
      position: relative;
    }
    .tooltip:hover:after {
      content: attr(data-tooltip);
      position: absolute;
      left: 0;
      top: 100%;
      margin-top: 8px;
      background: #1f2937;
      color: #fff;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      z-index: 10;
      }
    @media (max-width: 640px) {
      .tooltip:hover:after {
        white-space: normal; /* Allow wrapping for tooltips on mobile */
        max-width: 200px; /* Limit tooltip width */
      }
    }
  </style>
</head>
<body>
  <div class="container mx-auto max-w-4xl p-6 rounded-lg shadow-lg">
    <div class="flex justify-between items-center mb-4">
      <h1 class="text-3xl font-bold">FASTA Fragment Tiler</h1>
      <label class="toggle-switch" aria-label="Toggle dark mode">
        <input type="checkbox" id="themeToggle">
        <span class="slider"></span>
      </label>
    </div>
    <button id="toggleInstructions" class="text-indigo-600 font-medium mb-2 hover:underline">Hide Instructions</button>
    <div id="instructions" class="mb-4">
      <p class="text-gray-600 mb-4">
        This tool reads a FASTA file or manually entered sequence, generates fragments of the sequence into overlapping fragments of a specified length and overlap for helping to design gBlocks to order. Optionally, it adjusts each overlap to achieve user-specified GC%, avoid long repeats, and outputs the fragments in FASTA format.
      </p>
      <svg id="Layer_1" focusable="false" xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 516.74 131.32">
        <defs>
          <style>
            .st0, .st1 {
              fill: none;
              stroke: var(--svg-text);
              stroke-miterlimit: 10;
            }
            .st2, .st3, .st4 {
              fill: var(--svg-text);
            }
            .st5 {
              fill: #e21f26;
            }
            .st5, .st4 {
              opacity: .2;
            }
            .st3, .st6 {
              font-family: MyriadPro-Regular, 'Myriad Pro';
              font-size: 12px;
            }
            .st7 {
              fill: var(--svg-bg);
            }
            .st6 {
              fill: var(--svg-text-red);
            }
            .st1 {
              stroke-dasharray: 3.74 1.87;
            }
          </style>
        </defs>
        <rect class="st7" width="516.74" height="131.32"/>
        <g>
          <line class="st0" x1="258.37" y1="32.46" x2="258.37" y2="46.48"/>
          <polygon class="st2" points="258.37 50.72 255.93 44.75 258.37 46.16 260.81 44.75 258.37 50.72"/>
        </g>
        <text class="st3" transform="translate(218.89 18.74)"><tspan x="0" y="0">Input Sequence</tspan></text>
        <g>
          <line class="st0" x1="69.39" y1="27.24" x2="443.08" y2="27.24"/>
          <text class="st3" transform="translate(59.47 28.3)"><tspan x="0" y="0">5‚Äô</tspan></text>
          <text class="st3" transform="translate(448.91 28.3)"><tspan x="0" y="0">3‚Äô</tspan></text>
        </g>
        <g>
          <line class="st0" x1="54.77" y1="70.96" x2="174.74" y2="70.96"/>
          <line class="st0" x1="162.33" y1="78.1" x2="279.91" y2="78.1"/>
          <line class="st0" x1="355.58" y1="70.96" x2="389.06" y2="70.96"/>
          <g>
            <line class="st0" x1="318.05" y1="70.96" x2="320.05" y2="70.96"/>
            <line class="st1" x1="321.92" y1="70.96" x2="349.01" y2="70.96"/>
            <line class="st0" x1="349.95" y1="70.96" x2="351.95" y2="70.96"/>
          </g>
          <line class="st0" x1="267.51" y1="70.96" x2="314.66" y2="70.96"/>
          <line class="st0" x1="376.65" y1="78.1" x2="428.46" y2="78.1"/>
          <rect class="st4" x="162.33" y="70.96" width="12.41" height="25.48"/>
          <rect class="st5" x="54.77" y="65.36" width="12.41" height="12.41"/>
          <rect class="st5" x="416.05" y="71.56" width="12.41" height="12.41"/>
          <rect class="st4" x="267.51" y="70.96" width="12.41" height="25.48"/>
          <rect class="st4" x="376.65" y="70.96" width="12.41" height="25.48"/>
          <text class="st3" transform="translate(148.71 109.58)"><tspan x="0" y="0">Overlap</tspan></text>
          <text class="st6" transform="translate(403.94 93.42)"><tspan x="0" y="0">Homology to vector</tspan></text>
          <text class="st6" transform="translate(12.83 90.77)"><tspan x="0" y="0">Homology to vector</tspan></text>
          <text class="st3" transform="translate(256.8 109.58)"><tspan x="0" y="0">Overlap</tspan></text>
          <text class="st3" transform="translate(364.88 109.58)"><tspan x="0" y="0">Overlap</tspan></text>
          <text class="st3" transform="translate(79.84 63.81)"><tspan x="0" y="0">Fragment 1</tspan></text>
          <text class="st3" transform="translate(190.98 63.81)"><tspan x="0" y="0">Fragment 2</tspan></text>
          <text class="st3" transform="translate(302.13 63.81)"><tspan x="0" y="0">Fragment (n-1)</tspan></text>
          <text class="st3" transform="translate(406.5 63.81)"><tspan x="0" y="0">(n)</tspan></text>
          <text class="st3" transform="translate(44.85 74.53)"><tspan x="0" y="0">5‚Äô</tspan></text>
          <text class="st3" transform="translate(434.3 80.75)"><tspan x="0" y="0">3‚Äô</tspan></text>
        </g>
      </svg>
    </div>
    <div class="grid grid-cols-1 gap-4 mb-6">
      <div class="block w-full">
        <div class="flex space-x-4 mb-2">
          <label class="flex items-center">
            <input type="radio" name="inputType" value="file" checked class="mr-2 h-4 w-4 text-indigo-600 focus:ring-teal-500" aria-label="Select FASTA file upload" aria-controls="fileInputContainer">
            <span class="text-gray-700 font-medium">Upload FASTA file</span>
          </label>
          <label class="flex items-center">
            <input type="radio" name="inputType" value="sequence" class="mr-2 h-4 w-4 text-indigo-600 focus:ring-teal-500" aria-label="Select manual sequence input" aria-controls="sequenceInputContainer">
            <span class="text-gray-700 font-medium">Enter sequence manually</span>
          </label>
        </div>
        <div id="fileInputContainer" class="tooltip" data-tooltip="Upload a FASTA file (.fa, .fasta) with DNA sequence">
          <label class="block w-full">
            <span class="text-gray-700 font-medium">FASTA file:</span>
            <input type="file" id="fastaFile" accept=".fa,.fasta" aria-label="Upload FASTA file" class="mt-1 block w-full border border-gray-300 rounded-md p-2 focus:ring-teal-500 focus:border-teal-500">
            <span id="fileName" class="text-gray-500 text-sm"></span>
            <span id="seqLength" class="text-gray-500 text-sm block"></span>
            <span id="fastaFileError" class="text-red-600 text-sm hidden">Please select a FASTA file</span>
            <span id="fastaFormatError" class="text-red-600 text-sm hidden">Invalid FASTA format: must start with '>' or contain A, C, G, T, N</span>
          </label>
        </div>
        <div id="sequenceInputContainer" class="tooltip hidden" data-tooltip="Enter a FASTA sequence or plain DNA sequence (A, C, G, T, N)">
          <label class="block w-full">
            <span class="text-gray-700 font-medium">Enter sequence:</span>
            <textarea id="sequenceInput" rows="4" placeholder=">Header&#10;ACTG...&#10;OR&#10;ACTG..." aria-label="Enter sequence manually" class="mt-1 block w-full border border-gray-300 rounded-md p-2 focus:ring-teal-500 focus:border-teal-500"></textarea>
            <button id="exampleSequenceBtn" role="button" aria-label="Load example sequence" class="mt-2 bg-indigo-600 text-white font-semibold py-1 px-3 rounded-md hover:bg-teal-600 transition duration-200">Example Sequence</button>
            <span id="seqLengthSequence" class="text-gray-500 text-sm block"></span>
            <span id="sequenceError" class="text-red-600 text-sm hidden">Invalid sequence: use A, C, G, T, N, or FASTA format with '>' header</span>
          </label>
        </div>
      </div>
      <div class="flex flex-col md:flex-row space-x-0 md:space-x-4">
        <label class="block flex-1 tooltip" data-tooltip="Recommended: 1000‚Äì2000 bp for gBlocks">
          <span class="text-gray-700 font-medium">Fragment length:</span>
          <input type="number" id="length" value="1500" min="1" aria-label="Fragment length in bases" class="mt-1 block w-full border border-gray-300 rounded-md p-2 focus:ring-teal-500 focus:border-teal-500">
          <span id="lengthError" class="text-red-600 text-sm hidden">Fragment length must be a positive integer</span>
        </label>
        <label class="block flex-1 tooltip" data-tooltip="Recommended: 20‚Äì50 bp for overlaps">
          <span class="text-gray-700 font-medium">Overlap:</span>
          <input type="number" id="overlap" value="25" min="0" aria-label="Overlap between fragments" class="mt-1 block w-full border border-gray-300 rounded-md p-2 focus:ring-teal-500 focus:border-teal-500">
          <span id="overlapError" class="text-red-600 text-sm hidden">Overlap must be a non-negative integer and less than fragment length</span>
        </label>
      </div>
      <div class="flex flex-col md:flex-row space-x-0 md:space-x-4">
        <label class="block flex-1 tooltip" data-tooltip="Optional: 20‚Äì30 bp for vector homology (A, C, G, T)">
          <span class="text-gray-700 font-medium">5‚Ä≤ Homology sequence to the vector:</span>
          <input type="text" id="fivePrime" placeholder="AAGGAAGTGCCATTCCGCCTGACCT" aria-label="5‚Ä≤ homology sequence" class="mt-1 block w-full border border-gray-300 rounded-md p-2 focus:ring-teal-500 focus:border-teal-500">
          <span id="fivePrimeError" class="text-red-600 text-sm hidden">Invalid 5‚Ä≤ sequence: use A, C, G, T</span>
        </label>
        <label class="block flex-1 tooltip" data-tooltip="Optional: 20‚Äì30 bp for vector homology (A, C, G, T)">
          <span class="text-gray-700 font-medium">3‚Ä≤ Homology sequence to the vector:</span>
          <input type="text" id="threePrime" placeholder="AGGCTAGGTGGAGGCTCAGTGATGA" aria-label="3‚Ä≤ homology sequence" class="mt-1 block w-full border border-gray-300 rounded-md p-2 focus:ring-teal-500 focus:border-teal-500">
          <span id="threePrimeError" class="text-red-600 text-sm hidden">Invalid 3‚Ä≤ sequence: use A, C, G, T</span>
        </label>
      </div>
      <label class="block w-full flex items-center tooltip" data-tooltip="Optimize overlaps for GC content and avoid repeats">
        <input type="checkbox" id="gcBalance" class="mr-2 h-4 w-4 text-indigo-600 focus:ring-teal-500 border-gray-300 rounded" aria-label="Enforce GC% constraints">
        <span class="text-gray-700 font-medium">Enforce GC% & avoid 4+ mono/di/tri‚Äêrepeats in overlaps</span>
      </label>
      <div class="flex flex-col md:flex-row space-x-0 md:space-x-4">
        <label class="block flex-1 tooltip" data-tooltip="Recommended: 35‚Äì45% for overlaps">
          <span class="text-gray-700 font-medium">Minimum GC%:</span>
          <input type="number" id="gcMin" value="35" min="0" max="100" placeholder="35" aria-label="Minimum GC percentage" class="mt-1 block w-full border border-gray-300 rounded-md p-2 focus:ring-teal-500 focus:border-teal-500">
          <span id="gcMinError" class="text-red-600 text-sm hidden">Minimum GC% must be between 0 and 100</span>
        </label>
        <label class="block flex-1 tooltip" data-tooltip="Recommended: 55‚Äì65% for overlaps">
          <span class="text-gray-700 font-medium">Maximum GC%:</span>
          <input type="number" id="gcMax" value="60" min="0" max="100" placeholder="60" aria-label="Maximum GC percentage" class="mt-1 block w-full border border-gray-300 rounded-md p-2 focus:ring-teal-500 focus:border-teal-500">
          <span id="gcMaxError" class="text-red-600 text-sm hidden">Maximum GC% must be between 0 and 100</span>
        </label>
      </div>
      <label class="block w-full flex items-center tooltip" data-tooltip="Show a bar chart of fragment GC% distribution">
        <input type="checkbox" id="showHistogram" class="mr-2 h-4 w-4 text-indigo-600 focus:ring-teal-500 border-gray-300 rounded" aria-label="Show GC% histogram">
        <span class="text-gray-700 font-medium">Show GC% Histogram</span>
      </label>
    </div>
    <button id="processBtn" role="button" aria-label="Process FASTA file or sequence" class="w-full bg-indigo-600 text-white font-semibold py-2 px-4 rounded-md hover:bg-teal-600 transition duration-200 disabled:opacity-50">Process</button>
    <h2 class="text-2xl font-semibold mt-6 mb-4">Output</h2>
    <div id="progress" class="hidden text-center mb-4"><div class="inline-block animate-spin rounded-full h-8 w-8 border-t-2 border-teal-600"></div></div>
    <span id="fragCount" class="text-gray-500 text-sm block mb-2"></span>
    <div class="table-container">
      <table id="fragTable" class="hidden mb-4">
        <thead>
          <tr class="bg-gray-100">
            <th class="border p-2">Sequence</th>
            <th class="border p-2">Fragment</th>
            <th class="border p-2">Start</th>
            <th class="border p-2">End</th>
            <th class="border p-2">Length (bp)</th>
            <th class="border p-2">GC%</th>
          </tr>
        </thead>
        <tbody id="fragTableBody"></tbody>
      </table>
    </div>
    <div id="histogramContainer" class="hidden mb-4">
      <canvas id="gcHistogramCanvas"></canvas>
    </div>
    <div class="table-container">
        <table id="overlapTableContainer" class="hidden mb-4">
          <thead>
            <tr class="bg-gray-100">
              <th class="border p-2">Sequence</th>
              <th class="border p-2">Overlap</th>
              <th class="border p-2">Sequence</th>
              <th class="border p-2">Length (bp)</th>
              <th class="border p-2">GC%</th>
              <th class="border p-2">Rec. Temp Range (¬∞C)</th>
            </tr>
          </thead>
          <tbody id="overlapTableBody"></tbody>
        </table>
    </div>
    <div class="flex space-x-2 mb-4">
      <button id="downloadBtn" role="button" aria-label="Download FASTA output" class="bg-indigo-600 text-white font-semibold py-2 px-4 rounded-md hover:bg-teal-600 transition duration-200 hidden">Download FASTA</button>
      <button id="copyBtn" role="button" aria-label="Copy FASTA output to clipboard" class="bg-indigo-600 text-white font-semibold py-2 px-4 rounded-md hover:bg-teal-600 transition duration-200 hidden">Copy to Clipboard</button>
      <button id="downloadCsvBtn" role="button" aria-label="Download overlap table as CSV" class="bg-indigo-600 text-white font-semibold py-2 px-4 rounded-md hover:bg-teal-600 transition duration-200 hidden">Download Overlap CSV</button>
    </div>
    <pre id="outLog" class="border border-gray-200 rounded-md p-4 text-sm"></pre>
  </div>
  <footer>
    <p class="text-gray-600">Created by <a href="https://github.com/mbuyukyoruk" class="link-color" target="_blank" rel="noopener noreferrer">Murat Buyukyoruk</a></p>
  </footer>
<script>
/**
 * Robust FASTA parser: splits on leading ">", then first line is header,
 * subsequent lines are sequence. Also handles single-line entries and plain sequences.
 */
function parseFasta(text) {
  text = text.trim();
  const recs = [];
  let seqLength = 0;
  if (text.startsWith(">")) {
    const entries = text.split(/^>/m);
    for (let entry of entries) {
      entry = entry.trim();
      if (!entry) continue;
      const lines = entry.split(/[\r\n]+/);
      const headerLine = lines[0].trim();
      const id = headerLine.split(/\s+/)[0] || `Seq${recs.length + 1}`;
      let seq = "";
      if (lines.length > 1) {
        seq = lines.slice(1).join("").replace(/\s/g, "").toUpperCase();
      } else {
        const parts = entry.split(/\s+/);
        if (parts.length > 1) {
          seq = parts.slice(1).join("").toUpperCase();
        }
      }
      if (seq && /^[ACGTNacgtn]+$/.test(seq)) {
        recs.push({id, seq});
        seqLength += seq.length;
      }
    }
  } else if (/^[ACGTNacgtn]+$/.test(text.replace(/\s/g, ""))) {
    const seq = text.replace(/\s/g, "").toUpperCase();
    recs.push({id: "Seq1", seq});
    seqLength = seq.length;
  }
  const seqLengthEl = document.querySelector(document.querySelector('input[name="inputType"]:checked').value === "file" ? "#seqLength" : "#seqLengthSequence");
  seqLengthEl.textContent = seqLength ? `Total sequence length: ${seqLength} bases` : "";
  return recs;
}
/**
 * Validate FASTA or sequence text
 */
function isValidFastaOrSequence(text) {
  text = text.trim();
  if (text.startsWith(">")) {
    return /^>.*[\r\n]+[ACGTNacgtn]+/m.test(text);
  }
  return /^[ACGTNacgtn\s]+$/.test(text);
}
/**
 * Validate DNA sequence (A, C, G, T only)
 */
function isValidDNA(seq) {
  return /^[ACGTacgt]+$/.test(seq);
}
/**
 * Calculate GC content
 */
function gcContent(s) {
  let gc = 0;
  s = s.toUpperCase();
  for (let c of s) if (c === 'G' || c === 'C') gc++;
  return s.length ? gc / s.length : 0;
}
/**
 * Check for long mono/di/tri-nucleotide repeats
 */
function hasBadRepeats(s) {
  s = s.toUpperCase();
  if (/(A|C|G|T)\1{3,}/.test(s)) return true;
  if (/([ACGT]{2})\1{3,}/.test(s)) return true;
  if (/([ACGT]{3})\1{3,}/.test(s)) return true;
  return false;
}
/**
 * Estimate recommended annealing temperature range
 */
function estimateTempRange(seq) {
  const gcPercent = gcContent(seq) * 100;
  const length = seq.length;
  const baseTemp = 55 + 0.1 * gcPercent + 0.5 * (length - 25);
  const minTemp = Math.max(50, Math.round(baseTemp - 2.5));
  const maxTemp = Math.min(70, Math.round(baseTemp + 2.5));
  return `${minTemp}‚Äì${maxTemp}`;
}
/**
 * Slide overlap backward and forward to find GC% in [min, max] and no bad repeats.
 */
function adjustOverlap(seq, ideal, overlap, minGC, maxGC) {
  let bestPos = ideal;
  let bestGC = gcContent(seq.substr(ideal, overlap));
  let minGCDiff = Math.min(Math.abs(bestGC - minGC), Math.abs(bestGC - maxGC));
  const searchRange = 300;
  let validPos = null;
  for (let pos = ideal; pos >= Math.max(0, ideal - searchRange); pos--) {
    const w = seq.substr(pos, overlap);
    const gc = gcContent(w);
    if (gc >= minGC && gc <= maxGC && !hasBadRepeats(w)) {
      validPos = pos;
      break;
    }
    const diff = Math.min(Math.abs(gc - minGC), Math.abs(gc - maxGC));
    if (diff < minGCDiff) {
      minGCDiff = diff;
      bestPos = pos;
      bestGC = gc;
    }
  }
  if (!validPos) {
    for (let pos = ideal + 1; pos <= Math.min(seq.length - overlap, ideal + searchRange); pos++) {
      const w = seq.substr(pos, overlap);
      const gc = gcContent(w);
      if (gc >= minGC && gc <= maxGC && !hasBadRepeats(w)) {
        validPos = pos;
        break;
      }
      const diff = Math.min(Math.abs(gc - minGC), Math.abs(gc - maxGC));
      if (diff < minGCDiff) {
        minGCDiff = diff;
        bestPos = pos;
        bestGC = gc;
      }
    }
  }
  if (validPos !== null) {
    return validPos;
  }
  console.warn(`No valid overlap found with GC ${minGC*100}‚Äì${maxGC*100}% at position ${ideal}; trying relaxed GC 30‚Äì60%`);
  const relaxedMinGC = 0.30;
  for (let pos = ideal; pos >= Math.max(0, ideal - searchRange); pos--) {
    const w = seq.substr(pos, overlap);
    const gc = gcContent(w);
    if (gc >= relaxedMinGC && gc <= maxGC && !hasBadRepeats(w)) {
      console.warn(`Using relaxed GC at pos ${pos} with GC ${(gc*100).toFixed(2)}%`);
      return pos;
    }
  }
  for (let pos = ideal + 1; pos <= Math.min(seq.length - overlap, ideal + searchRange); pos++) {
    const w = seq.substr(pos, overlap);
    const gc = gcContent(w);
    if (gc >= relaxedMinGC && gc <= maxGC && !hasBadRepeats(w)) {
      console.warn(`Using relaxed GC at pos ${pos} with GC ${(gc*100).toFixed(2)}%`);
      return pos;
    }
  }
  console.warn(`No valid overlap found even with relaxed GC 30‚Äì60% at position ${ideal}; using pos ${bestPos} with GC ${(bestGC*100).toFixed(2)}%`);
  return bestPos;
}
/**
 * Generate sequence fragments
 */
function fragmentSequence(seq, L, O, fivePrime, threePrime) {
  const frags = [];
  let pos = 0;
  const hasAdapters = fivePrime || threePrime;
  if (!hasAdapters) {
    frags.push({ start: 0, end: Math.min(L, seq.length) });
    pos = L - O;
  } else {
    const firstLen = L - O;
    frags.push({ start: 0, end: Math.min(firstLen, seq.length) });
    pos = firstLen - O;
  }
  while (pos + L < seq.length) {
    frags.push({ start: pos, end: Math.min(pos + L, seq.length) });
    pos = pos + L - O;
  }
  if (pos < seq.length) {
    frags.push({ start: pos, end: seq.length });
  }
  return frags;
}
/**
 * Re-split oversized fragments and merge short fragments
 */
function resplitFragments(frags, L, O, seqLength) {
  const newFrags = [];
  let i = 0;
  while (i < frags.length) {
    let { start, end } = frags[i];
    if (i < frags.length - 1 && end - start > L) {
      let pos = start;
      while (pos + L < end) {
        newFrags.push({ start: pos, end: Math.min(pos + L, seqLength) });
        pos += L - O;
      }
      if (pos < end) {
        newFrags.push({ start: pos, end });
      }
      i++;
    } else if (i < frags.length - 1 && end - start < 1000 && i + 1 < frags.length) {
      const next = frags[i + 1];
      const combinedLen = next.end - start;
      if (combinedLen <= L + O) {
        newFrags.push({ start, end: next.end });
        i += 2;
      } else {
        newFrags.push({ start, end });
        i++;
      }
    } else {
      newFrags.push({ start, end });
      i++;
    }
  }
  if (newFrags.length > 1 && newFrags[newFrags.length - 1].end - newFrags[newFrags.length - 1].start < 1000) {
    const last = newFrags.pop();
    const prev = newFrags[newFrags.length - 1];
    if (last.end - prev.start <= L + O) {
      prev.end = last.end;
    } else {
      newFrags.push(last);
    }
  }
  return newFrags;
}
/**
 * Save input values to localStorage
 */
function saveInputs() {
  const inputs = ["length", "overlap", "fivePrime", "threePrime", "gcMin", "gcMax", "gcBalance", "showHistogram"];
  inputs.forEach(id => {
    const el = document.getElementById(id);
    localStorage.setItem(id, el.type === "checkbox" ? el.checked : el.value);
  });
}
/**
 * Load input values from localStorage
 */
function loadInputs() {
  const inputs = [
    { id: "length", default: "1500" },
    { id: "overlap", default: "25" },
    { id: "fivePrime", default: "" },
    { id: "threePrime", default: "" },
    { id: "gcMin", default: "35" },
    { id: "gcMax", default: "60" },
    { id: "gcBalance", default: false, type: "checkbox" },
    { id: "showHistogram", default: false, type: "checkbox" }
  ];
  inputs.forEach(({ id, default: def, type }) => {
    const value = localStorage.getItem(id);
    const el = document.getElementById(id);
    if (value !== null) {
      el[type === "checkbox" ? "checked" : "value"] = type === "checkbox" ? value === "true" : value;
    } else {
      el[type === "checkbox" ? "checked" : "value"] = def;
    }
  });
  toggleGCFields();
}
/**
 * Clear output elements
 */
function clearOutput() {
  document.getElementById("outLog").textContent = "";
  document.getElementById("downloadBtn").style.display = "none";
  document.getElementById("copyBtn").style.display = "none";
  document.getElementById("downloadCsvBtn").style.display = "none";
  document.getElementById("fragTable").classList.add("hidden");
  document.getElementById("fragCount").textContent = "";
  document.getElementById("histogramContainer").classList.add("hidden");
  document.getElementById("overlapTableContainer").classList.add("hidden");
  const canvas = document.getElementById("gcHistogramCanvas");
  if (canvas) canvas.getContext("2d").clearRect(0, 0, canvas.width, canvas.height);
}
/**
 * Draw GC% histogram with animation and distinct colors per sequence
 */
function drawHistogram(gcData) {
  if (!gcData || !Array.isArray(gcData) || gcData.length === 0 || gcData.every(seq => !seq.fragments || seq.fragments.length === 0)) {
    console.warn("No valid GC data provided for histogram");
    document.getElementById("histogramContainer").classList.add("hidden");
    return;
  }
  const canvas = document.getElementById("gcHistogramCanvas");
  const ctx = canvas.getContext("2d");
  canvas.width = canvas.parentElement.offsetWidth * 0.95;

  // Calculate the longest label width
  ctx.font = "14px Inter"; // Match font used for x-axis labels
  let maxLabelWidth = 0;
  gcData.forEach((seq, seqIdx) => {
    if (seq.fragments) {
      seq.fragments.forEach((frag, fragIdx) => {
        const label = `${seq.id}_F${fragIdx + 1}`;
        const textWidth = ctx.measureText(label).width;
        maxLabelWidth = Math.max(maxLabelWidth, textWidth);
      });
    }
  });
  // Since labels are rotated -90 degrees, their width becomes height
  // Add padding (e.g., 30px for x-axis title, 10px for spacing, 20px buffer)
  const isMobile = window.innerWidth <= 640;
  const bottomMargin = isMobile ? maxLabelWidth + 20 : maxLabelWidth + 30 + 10 + 20; // Reduced bottom margin on mobile
  const margin = { top: isMobile ? 40 : 60, right: 20, bottom: bottomMargin, left: isMobile ? 60 : 80 };
  // Set canvas height: plot height + top margin + bottom margin
  const plotHeight = isMobile ? 300 : 400; // Reduced height on mobile
  canvas.height = plotHeight + margin.top + margin.bottom;

  const plotWidth = canvas.width - margin.left - margin.right;
  const totalFragments = gcData.reduce((sum, seq) => sum + (seq.fragments ? seq.fragments.length : 0), 0);
  if (totalFragments === 0) {
    console.warn("No fragments available to plot in histogram");
    document.getElementById("histogramContainer").classList.add("hidden");
    return;
  }
  const barWidth = Math.min(isMobile ? 30 : 40, plotWidth / totalFragments * 0.8);
  const barSpacing = (plotWidth - barWidth * totalFragments) / (totalFragments + 1);
  const gcValues = gcData.flatMap(seq => seq.fragments ? seq.fragments.map(f => f.gc * 100) : []);
  const maxGC = gcValues.length > 0 ? Math.ceil(Math.max(...gcValues) / 10) * 10 : 100;
  const minGC = gcValues.length > 0 ? Math.floor(Math.min(...gcValues) / 10) * 10 : 0;
  const gcRange = maxGC - minGC || 100;
  const barHeightScale = plotHeight / gcRange;
  // Define colors for each sequence
  const colors = [
    "rgba(20,184,166,0.9)", // Teal for Seq1
    "rgba(249,115,22,0.9)", // Orange for Seq2
    "rgba(59,130,246,0.9)", // Blue for Seq3
    "rgba(147,51,234,0.9)", // Purple for Seq4
    "rgba(239,68,68,0.9)"  // Red for Seq5
  ];
  const hoverColors = [
    "rgba(13,148,136,0.9)", // Teal hover
    "rgba(194,65,12,0.9)", // Orange hover
    "rgba(29,78,216,0.9)", // Blue hover
    "rgba(126,34,206,0.9)", // Purple hover
    "rgba(220,38,38,0.9)"  // Red hover
  ];
  let animationProgress = 0;
  const animationDuration = 500;
  const draw = (progress, hoverIndex = -1) => {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = `var(--histogram-grid)`;
    ctx.lineWidth = 0.5;
    for (let gc = minGC; gc <= maxGC; gc += 10) {
      const y = margin.top + plotHeight - ((gc - minGC) * barHeightScale);
      ctx.beginPath();
      ctx.moveTo(margin.left, y);
      ctx.lineTo(margin.left + plotWidth, y);
      ctx.stroke();
    }
    ctx.beginPath();
    ctx.moveTo(margin.left, margin.top);
    ctx.lineTo(margin.left, margin.top + plotHeight);
    ctx.lineTo(margin.left + plotWidth, margin.top + plotHeight);
    ctx.strokeStyle = "#000000";
    ctx.lineWidth = 1;
    ctx.stroke();
    ctx.font = isMobile ? "12px Inter" : "14px Inter";
    ctx.fillStyle = "#000000";
    ctx.textAlign = "right";
    ctx.textBaseline = "middle";
    for (let gc = minGC; gc <= maxGC; gc += 10) {
      const y = margin.top + plotHeight - ((gc - minGC) * barHeightScale);
      ctx.fillText(`${gc}%`, margin.left - 10, y);
    }
    // Draw x-axis labels with -90 degree tilt
    let barIndex = 0;
    gcData.forEach((seq, seqIdx) => {
      if (seq.fragments) {
        seq.fragments.forEach((frag, fragIdx) => {
          const label = `${seq.id}_F${fragIdx + 1}`;
          const x = margin.left + barSpacing * (barIndex + 1) + barWidth * barIndex + barWidth / 2;
          const y = margin.top + plotHeight + 10; // Base y for rotation
          ctx.save();
          ctx.translate(x, y);
          ctx.rotate(isMobile ? -Math.PI / 2 : -Math.PI / 3);
          ctx.textAlign = "right";
          ctx.textBaseline = "top";
          ctx.fillText(label, 0, 0);
          ctx.restore();
          barIndex++;
        });
      }
    });
    // Draw x-axis title
    ctx.font = isMobile ? "14px Inter" : "16px Inter";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    ctx.fillText("Fragments", canvas.width / 2, margin.top + plotHeight + (isMobile ? maxLabelWidth + 15 : maxLabelWidth + 15));
    // Draw y-axis title
    ctx.font = isMobile ? "14px Inter" : "16px Inter";
    ctx.fillStyle = "#000000";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.save();
    ctx.translate(margin.left / 2 - (isMobile ? 15 : 20), margin.top + plotHeight / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText("GC Content (%)", 0, 0);
    ctx.restore();
    // Draw main title
    ctx.font = isMobile ? "16px Inter" : "20px Inter";
    ctx.fillStyle = "#000000";
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    ctx.fillText("GC Content Distribution", canvas.width / 2, margin.top / 2 - (isMobile ? 15 : 20));
    // Draw bars
    barIndex = 0;
    gcData.forEach((seq, seqIdx) => {
      if (seq.fragments) {
        seq.fragments.forEach((frag, fragIdx) => {
          const height = (frag.gc * 100 - minGC) * barHeightScale * progress;
          const x = margin.left + barSpacing * (barIndex + 1) + barWidth * barIndex;
          const y = margin.top + plotHeight - height;
          ctx.fillStyle = barIndex === hoverIndex ? hoverColors[seqIdx % hoverColors.length] : colors[seqIdx % colors.length];
          ctx.shadowColor = "rgba(0,0,0,0.2)";
          ctx.shadowBlur = barIndex === hoverIndex ? 6 : 4;
          ctx.beginPath();
          ctx.moveTo(x + 6, y);
          ctx.arcTo(x, y, x, y + 6, 6);
          ctx.lineTo(x, y + height - 6);
          ctx.arcTo(x, y + height, x + 6, y + height, 6);
          ctx.lineTo(x + barWidth - 6, y + height);
          ctx.arcTo(x + barWidth, y + height, x + barWidth, y + height - 6, 6);
          ctx.lineTo(x + barWidth, y + 6);
          ctx.arcTo(x + barWidth, y, x + barWidth - 6, y, 6);
          ctx.closePath();
          ctx.fill();
          ctx.shadowBlur = 0;
          ctx.font = isMobile ? "10px Inter" : "12px Inter";
          ctx.fillStyle = "#000000";
          ctx.fillText(`${(frag.gc * 100).toFixed(1)}%`, x + barWidth / 2, y - (isMobile ? 15 : 20));
          barIndex++;
        });
      }
    });
  };
  const startTime = performance.now();
  const animate = (time) => {
    animationProgress = Math.min((time - startTime) / animationDuration, 1);
    draw(animationProgress);
    if (animationProgress < 1) {
      requestAnimationFrame(animate);
    }
  };
  requestAnimationFrame(animate);
  canvas.onmousemove = (e) => {
    const rect = canvas.getContext("2d").canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    let hoverIndex = -1;
    let barIndex = 0;
    gcData.forEach(seq => {
      if (seq.fragments) {
        seq.fragments.forEach((frag) => {
          const x = margin.left + barSpacing * (barIndex + 1) + barWidth * barIndex;
          const height = (frag.gc * 100 - minGC) * barHeightScale;
          const y = margin.top + plotHeight - height;
          if (mouseX >= x && mouseX <= x + barWidth && mouseY >= y && mouseY <= margin.top + plotHeight) {
            hoverIndex = barIndex;
          }
          barIndex++;
        });
      }
    });
    draw(1, hoverIndex);
    canvas.style.cursor = hoverIndex >= 0 ? "pointer" : "default";
  };
  canvas.onmouseout = () => {
    draw(1);
    canvas.style.cursor = "default";
  };
  console.log("Histogram drawn with GC values:", gcData.map(seq => ({
    id: seq.id,
    fragments: seq.fragments ? seq.fragments.map(f => (f.gc * 100).toFixed(1) + "%") : []
  })));
}
/**
 * Clear input error styles
 */
function clearInputErrors() {
  const inputs = ["fastaFile", "sequenceInput", "length", "overlap", "fivePrime", "threePrime", "gcMin", "gcMax"];
  inputs.forEach(id => {
    const el = document.getElementById(id);
    el.classList.remove("input-error");
  });
  const errors = ["fastaFileError", "fastaFormatError", "sequenceError", "lengthError", "overlapError", "fivePrimeError", "threePrimeError", "gcMinError", "gcMaxError"];
  errors.forEach(id => document.getElementById(id).classList.add("hidden"));
}
/**
 * Toggle GC input fields based on gcBalance checkbox
 */
function toggleGCFields() {
  const checkbox = document.getElementById("gcBalance");
  const gcMinLabel = document.getElementById("gcMin").parentElement;
  const gcMaxLabel = document.getElementById("gcMax").parentElement;
  const gcMinInput = document.getElementById("gcMin");
  const gcMaxInput = document.getElementById("gcMax");
  if (checkbox.checked) {
    gcMinLabel.style.display = "block";
    gcMaxLabel.style.display = "block";
    gcMinInput.disabled = false;
    gcMaxInput.disabled = false;
  } else {
    gcMinLabel.style.display = "none";
    gcMaxLabel.style.display = "none";
    gcMinInput.disabled = true;
    gcMaxInput.disabled = true;
  }
}
/**
 * Load example sequence
 */
function loadExampleSequence() {
  const sequenceInput = document.getElementById("sequenceInput");
  sequenceInput.value = ">Example_sequence\nTTTCTTTTTCAACATCGGCTTTGTTAAGCCCTAAAGTATTTAATTTCATAAGATATTTGT\nTTTTAAAATTCTACGCCGCAAAGGTACGCCATTTTTTGCTGAAAAGAACGCCATAACGAT\nAGATATTTCTAATTTTAGAATAAGCAAACATTTTGCTACTTTATTAAAAATACTGCAATT\nATATCTTCAGTACAGAAAGGATATATAATGGATATAGGAAGAATACAGGAAGCCTCAACA\nAAATCTATTATCAAATCAGCAACAAAAATATCGAAACATTGCAAATAATGCAATACCACT\nTCTACTACTCCCACTCGTCCCACTTGTCTCACCTGTCCCACTCGTCTTACTAACGAAAAT\nCAAAAATACAAGCAACAAACTCACATTAGTGAAAATATAGTAATTTTGTTTTTTAGCAAA\nAAGATGTATATTTGCACTTTGTTTTTGAAGAATGAATGTAAATATTTGTAACATATTAAA\nTGTAGAAGTTTCCTTTCAAGAAAACACTTGGACAGAGATTACTAAAAATATATCCATTCA\nACAAGTGTTAAATATCATAAAAAAGGAGGAATATAAAAATGTAATAGGAAAATTGCGTAA\nTGAACTTGAAAAGGGAAATATAGAATATTATAATAGCAATAAGAAAAGATTGCCAGCTGT\nTACCTTTTCAGGAACATTTAAAAAGAAAAGAACTCTTGATTATATTCAATCTTATAATCC\nTATTGTTGTTATTGACATAGATAAATTAGATAATGAGGAACTTGATAGAGTTTATGATGT\nATTAGCTAAAGAACCCTATGTACTTAGTTTTTGGAAATCACCTTCAAATAAAGGTTTTAA\nAGGGATTGTACCTCTAAATTATAATACTGATAGTCAAGATTCAAACTTAATTCATAAATC\nTGCTTTCGAAAAACTATCTGAGTATTTTAAAAAAGAACATAATATAGAACTTGATAAGAG\nTGGGAGCGATATTACACGATTATGTTTTATTTCTTCTGATAAAGAGTTAGTTTTAAAAGA\nAGAAGTTACTTTTTTCAAAGTTGAGGATGAAGATTTATTAGATAACAAAAGTAGTAAAAC\nTGATGAAAAAATAAAACATTATGTTTTGAAATTTTCTAATAAAAGAGATGCTTTATATAA\nTCCTAAAAATAGGAATAAACCTAAAGACAGAACTGCTATGTCGAATATAATTAAATATCT\nTAAAGTTAAAAATAAAAGTATAACCTATAGCTATGCCAATTGGTATAAAGTAGCTATGGG\nAATAGCTAATTCATTTACATTTGACATAGGGAAAAAATATTTTAACAAATTAAGTGCTTT\nAGATGTTGGTAAATACAATTCTATTAATTGTGAAAACTTTTTAACTGACTGCTATGAAAT\nACGAAATGGCTCTATCACGTTTGCCTCGATAATATATTTAGCAAATCAGCAAGGTTATAA\nACAAAATCTCAAAAAAATAAAGGGGGGTTCTGAAGACGGCGGACAAAAACAACTGTCGTA\nAGTATCACTCCATTAACGGTAAGTTACTGCCTGAGAGCTTAAAATAGGACATAAGGCATA\nTCTATGTCAGAATATTTGGTATGCAATATCAATAGCGGGAACCCCCTTTATTATCTATGA\nAACCAATAGAAGATTTTTTATCAGAAACAGAAATTATAAAAAGTATTTGTAAAATCAGAG\nTTAAGCTAGCTAAGAGTAGGTCTAAAAAACATTTGTTAAATTACTTAACTAAAAATCCAA\nAATATAATTATCATCAAAGTATTAAACTTACAAATGAATTAGAAAAACTTCAATTTGAGA\nTAGATAAACAACTAAAAAAAATACTTCCCCCAAGAAAAAAATGGAAGGAGCCTTTACTTC\nCTATAATAGACAATGAGAGTAGAAAAATTATTAAAAGAAGAGAATTCAAAAATTCTTCTG\nACAGAAATTTCTATTCATTACTAAATACAATTAAGTATTATAAAAACATCAATTCACAAG\nAAACGTGGCTTTTAAATTTAACTAAGTTTGTTACTGAAATTAGAGATATTCTGATAGATA\nAAAAATATACTTTAACTTCTCCTATTGTAATTCCTAAACTAAAAAATGAAAAAATACAAA\nAAGAAGAAAATGAATGTCGCCCAATATGTATGTTCAATTTAAAAGATAGAATTGTTCTAA\nGTATTGTCAATAAGTTTTTAACTTATTTATTTGATAGTACTTTTGAAAATACTTCTTATG\nCTTTCAGAATTAAGAAAAATAGTGAGGGGAAAAATCTCTCACATCACGATTGTATAAGAG\nACATTCTAAAATACAAAGAACAATATAGTAATGAACAACTATTCATAGTAGAATGCGATA\nTGCAAAAATTTTATGATACAGTTAATCATAATATTATAAAAGAAGAATTTAATACTCTCA\nTTTCAGAGGCTAAAGAACACTATCCTAATTTAGATTTAGATTTAGCTATAAATATATTTC\nACAATTATTTAGAATGTTTTTGCTTTAATAAGGATATTCCTAAAAGAGAAGAATTAGAGT\nATTGGAAATCATATAAAATACCTAATGGTTTTTTTGGTTGGATTAACGAAAAGGAACTGT\nTAGATTATAAAATTAATATTAATACAGAGAGGATGGGAGTTCCTCAAGGAGGTGCTCTTT\nCAGGGTTAATTGCAAATATTTATCTCAATAAGGTTGACAAAAAACTAGCTACATTTAAAA\nATATCTTTTATGCAAGATTTTGTGATGATATGATAATTATATCTCCTTCTCAAGAAGAAT\nGCGAAAAATCTAAAGAAGTTTATATAAAAACTTTGAAAGAATTAAAATTATTTCCCCATT\nTATTTCAAAAAAATGAAGACTTACTAAATGTAAAAAATAACAGGAAAAATTACAAAGCTT\nTTTGGAAAGGAAAATCCAAAGGTTCCTATTTATGGGCACGTGAAGAAAATGATAAATTAT\nCTTTTCCTTGGATAGGTTTTGTAGGATATGAGATTAATTATAAAGGAGAAGTTAGAGTTA\nGAAAAAAATCTCTTCAAAAAGAGCTTAAAAAACAAAGAACAATTGTTGAAGAAATAAAAA\nAAGCTGTTTGTAAAGGACAAAGATGTTCCAAATATACAGTTATTGAATCAGCAATTAACC\nGATTGATAGGAATGTCTGTTGGAAGAGTAAAAATGTATAACTATGATAAAGTTCCTGCTA\nATCTATGTTGGAAAAATGGCTTTAAAGAGCTAACACTCAATAAATACTCATTAAAGCAAG\nTAAAAGAACTAGACCGTAATAGAAATAAATTATATTATAGATTATTTAAAGAGATTGATG\nAAAAGGAGTCTAAAAGTAAAAGCAAAACAAGAAGACTTCCATATAAATATAATAAACCTT\nTCAGTTATTATTATCAAATTTTGGAAAGAGGAAGATGAAATATCAATTTGGTATAAAATT\nTAGCAGAGAATTTGTGTTGTAATTCCCATTTTCTTTATAAAAGGGCTACAAAAAAAGAGC\nTATCCAAAACCTTTTGGATAACTCTTTTTTAATCGTCAAATTGTCAAATTGCCAAATCGA\nCAAATCGACAAATTAGTCTGATAGTCCTAATTCTTCTATAGCAGGTTCTTCCTCTTCTTG\nAGTCTCTACTTTCTTAGCTATAAATTTCTCTAAAGGCTGGTTGTTGAGGTTATAAACTAC\nCGATTGAGCGTCCAACTCGTCTAAAAACGCATTGTTGATACTTACTTTCAGCTGTGCATT";
  parseFasta(sequenceInput.value);
  clearOutput();
}
document.getElementById("processBtn").onclick = async () => {
  const btn = document.getElementById("processBtn");
  btn.disabled = true;
  btn.textContent = "Processing...";
  document.getElementById("progress").classList.remove("hidden");
  clearOutput();
  clearInputErrors();
  const inputType = document.querySelector('input[name="inputType"]:checked').value;
  let text = "";
  let file = null;
  if (inputType === "file") {
    file = document.getElementById("fastaFile").files[0];
    if (!file) {
      document.getElementById("fastaFileError").classList.remove("hidden");
      document.getElementById("fastaFile").classList.add("input-error");
      btn.disabled = false;
      btn.textContent = "Process";
      document.getElementById("progress").classList.add("hidden");
      return;
    }
    text = await file.text();
    if (!isValidFastaOrSequence(text)) {
      document.getElementById("fastaFormatError").classList.remove("hidden");
      document.getElementById("fastaFile").classList.add("input-error");
      btn.disabled = false;
      btn.textContent = "Process";
      document.getElementById("progress").classList.add("hidden");
      return;
    }
  } else {
    text = document.getElementById("sequenceInput").value.trim();
    if (!text || !isValidFastaOrSequence(text)) {
      document.getElementById("sequenceError").classList.remove("hidden");
      document.getElementById("sequenceInput").classList.add("input-error");
      btn.disabled = false;
      btn.textContent = "Process";
      document.getElementById("progress").classList.add("hidden");
      return;
    }
  }
  const L = +document.getElementById("length").value;
  const O = +document.getElementById("overlap").value;
  const five = document.getElementById("fivePrime").value.trim();
  const three = document.getElementById("threePrime").value.trim();
  const doGC = document.getElementById("gcBalance").checked;
  const gcMin = parseFloat(document.getElementById("gcMin").value) / 100;
  const gcMax = parseFloat(document.getElementById("gcMax").value) / 100;
  const showHistogram = document.getElementById("showHistogram").checked;
  // Validate inputs
  if (isNaN(L) || L < 1) {
    document.getElementById("lengthError").classList.remove("hidden");
    document.getElementById("length").classList.add("input-error");
    btn.disabled = false;
    btn.textContent = "Process";
    document.getElementById("progress").classList.add("hidden");
    return;
  }
  if (isNaN(O) || O < 0 || O >= L) {
    document.getElementById("overlapError").textContent = O >= L ? "Overlap must be less than fragment length" : "Overlap must be a non-negative integer";
    document.getElementById("overlapError").classList.remove("hidden");
    document.getElementById("overlap").classList.add("input-error");
    btn.disabled = false;
    btn.textContent = "Process";
    document.getElementById("progress").classList.add("hidden");
    return;
  }
  if (five && !isValidDNA(five)) {
    document.getElementById("fivePrimeError").classList.remove("hidden");
    document.getElementById("fivePrime").classList.add("input-error");
    btn.disabled = false;
    btn.textContent = "Process";
    document.getElementById("progress").classList.add("hidden");
    return;
  }
  if (three && !isValidDNA(three)) {
    document.getElementById("threePrimeError").classList.remove("hidden");
    document.getElementById("threePrime").classList.add("input-error");
    btn.disabled = false;
    btn.textContent = "Process";
    document.getElementById("progress").classList.add("hidden");
    return;
  }
  if (doGC) {
    if (isNaN(gcMin) || gcMin < 0 || gcMin > 1) {
      document.getElementById("gcMinError").classList.remove("hidden");
      document.getElementById("gcMin").classList.add("input-error");
      btn.disabled = false;
      btn.textContent = "Process";
      document.getElementById("progress").classList.add("hidden");
      return;
    }
    if (isNaN(gcMax) || gcMax < 0 || gcMax > 1) {
      document.getElementById("gcMaxError").classList.remove("hidden");
      document.getElementById("gcMax").classList.add("input-error");
      btn.disabled = false;
      btn.textContent = "Process";
      document.getElementById("progress").classList.add("hidden");
      return;
    }
    if (gcMin > gcMax) {
      document.getElementById("gcMaxError").textContent = "Minimum GC% must be less than or equal to Maximum GC%";
      document.getElementById("gcMaxError").classList.remove("hidden");
      document.getElementById("gcMax").classList.add("input-error");
      btn.disabled = false;
      btn.textContent = "Process";
      document.getElementById("progress").classList.add("hidden");
      return;
    }
  }
  const records = parseFasta(text);
  if (records.length === 0) {
    document.getElementById("sequenceError").textContent = "No valid sequences found";
    document.getElementById("sequenceError").classList.remove("hidden");
    document.getElementById(inputType === "file" ? "fastaFile" : "sequenceInput").classList.add("input-error");
    btn.disabled = false;
    btn.textContent = "Process";
    document.getElementById("progress").classList.add("hidden");
    return;
  }
  window.GC_MIN = doGC ? gcMin : 0.35;
  window.GC_MAX = doGC ? gcMax : 0.60;
  let out = "";
  let csvContent = "Sequence,Overlap,Sequence,Length (bp),GC%,Rec. Temp Range (¬∞C)\n";
  let allFrags = [];
  let gcData = [];
  let totalFragments = 0;
  for (let rec of records) {
    let frags = fragmentSequence(rec.seq, L, O, five, three);
    if (doGC) {
      for (let j = 0; j < frags.length - 1; j++) {
        const cur = frags[j], nxt = frags[j+1];
        const ideal = cur.end - O;
        const best = adjustOverlap(rec.seq, ideal, O, window.GC_MIN, window.GC_MAX);
        cur.end = best + O;
        nxt.start = best;
        if (j + 1 < frags.length - 1) {
          nxt.end = Math.min(best + L, rec.seq.length);
        }
        for (let k = j + 1; k < frags.length - 1; k++) {
          frags[k].start = frags[k-1].end - O;
          frags[k].end = Math.min(frags[k].start + L, rec.seq.length);
        }
        if (nxt.end - nxt.start < O && j + 1 < frags.length - 1) {
          console.warn(`Fragment ${j+2} too short (${nxt.end - nxt.start} bases) in sequence ${rec.id}; adjusting...`);
          nxt.end = Math.min(nxt.start + L, rec.seq.length);
        }
        const overlapSeq = rec.seq.slice(best, best + O);
        const gc = gcContent(overlapSeq);
        if (gc < window.GC_MIN || gc > window.GC_MAX || hasBadRepeats(overlapSeq)) {
          console.warn(`Overlap ${j+1} at ${best}-${best+O} in sequence ${rec.id} has GC ${(gc*100).toFixed(2)}% or bad repeats: ${overlapSeq}`);
        }
      }
      frags = resplitFragments(frags, L, O, rec.seq.length);
      for (let j = 0; j < frags.length - 1; j++) {
        const cur = frags[j], nxt = frags[j+1];
        const ideal = cur.end - O;
        const best = adjustOverlap(rec.seq, ideal, O, window.GC_MIN, window.GC_MAX);
        cur.end = best + O;
        nxt.start = best;
        if (j + 1 < frags.length - 1) {
          nxt.end = Math.min(best + L, rec.seq.length);
        }
        const overlapSeq = rec.seq.slice(best, best + O);
        const gc = gcContent(overlapSeq);
        if (gc < window.GC_MIN || gc > window.GC_MAX || hasBadRepeats(overlapSeq)) {
          console.warn(`Overlap ${j+1} at ${best}-${best+O} in sequence ${rec.id} has GC ${(gc*100).toFixed(2)}% or bad repeats: ${overlapSeq}`);
        }
      }
      frags = resplitFragments(frags, L, O, rec.seq.length);
    }
    frags = frags.filter((frag, i) => {
      if (i === 0 || i === frags.length - 1) return true;
      const len = frag.end - frag.start;
      if (len < O) {
        console.warn(`Removing fragment ${i+1} with length ${len} (less than overlap ${O}) in sequence ${rec.id}`);
        return false;
      }
      return true;
    });
    const seqGcData = { id: rec.id, fragments: [] };
    frags.forEach((frag, i) => {
      const gc = gcContent(rec.seq.slice(frag.start, frag.end));
      allFrags.push({ seqId: rec.id, fragId: `F${i+1}_${frag.start+1}_${frag.end}`, start: frag.start + 1, end: frag.end, length: frag.end - frag.start, gc });
      seqGcData.fragments.push({ gc, fragId: i + 1 });
    });
    if (seqGcData.fragments.length > 0) {
      gcData.push(seqGcData);
    }
    totalFragments += frags.length;
    if (frags.length > 1) {
      for (let i = 0; i < frags.length - 1; i++) {
        const cur = frags[i];
        const next = frags[i + 1];
        const overlapStart = next.start;
        const overlapEnd = cur.end;
        const overlapSeq = rec.seq.slice(overlapStart, overlapEnd);
        const overlapLength = overlapEnd - overlapStart;
        const gcPercent = (gcContent(overlapSeq) * 100).toFixed(2);
        const tempRange = estimateTempRange(overlapSeq);
        csvContent += `${rec.id},Overlap ${i + 1},${overlapSeq},${overlapLength},${gcPercent},${tempRange}\n`;
      }
    }
    for (let i = 0; i < frags.length; i++) {
      let {start, end} = frags[i];
      let seqFrag = rec.seq.slice(start, end);
      if (i === 0 && five) seqFrag = five + seqFrag;
      if (i === frags.length - 1 && three) seqFrag += three;
      out += `>${rec.id}_${start+1}_${end}\n`;
      for (let k = 0; k < seqFrag.length; k += 90) {
        out += seqFrag.substr(k, 90) + "\n";
      }
    }
  }
  const tableBody = document.getElementById("fragTableBody");
  tableBody.innerHTML = "";
  allFrags.forEach(frag => {
    const gcDisplay = frag.gc ? (frag.gc * 100).toFixed(2) : "N/A";
    tableBody.insertAdjacentHTML("beforeend", `<tr><td class="border p-2">${frag.seqId}</td><td class="border p-2">${frag.fragId}</td><td class="border p-2">${frag.start}</td><td class="border p-2">${frag.end}</td><td class="border p-2">${frag.length}</td><td class="border p-2">${gcDisplay}</td></tr>`);
  });
  document.getElementById("fragTable").classList.remove("hidden");
  document.getElementById("fragCount").textContent = `Generated ${totalFragments} fragments across ${records.length} sequences`;
  const overlapTableBody = document.getElementById("overlapTableBody");
  overlapTableBody.innerHTML = "";
  if (allFrags.length > records.length) {
    document.getElementById("overlapTableContainer").classList.remove("hidden");
    for (let rec of records) {
      const frags = allFrags.filter(f => f.seqId === rec.id);
      for (let i = 0; i < frags.length - 1; i++) {
        const cur = frags[i];
        const next = frags[i + 1];
        const overlapStart = next.start - 1;
        const overlapEnd = cur.end;
        const overlapSeq = rec.seq.slice(overlapStart, overlapEnd);
        const overlapLength = overlapEnd - overlapStart;
        const gcPercent = (gcContent(overlapSeq) * 100).toFixed(2);
        const tempRange = estimateTempRange(overlapSeq);
        overlapTableBody.insertAdjacentHTML("beforeend", `<tr><td class="border p-2">${rec.id}</td><td class="border p-2">Overlap ${i + 1}</td><td class="border p-2 font-mono text-sm break-words whitespace-normal max-w-xs">${overlapSeq}</td><td class="border p-2">${overlapLength}</td><td class="border p-2">${gcPercent}</td><td class="border p-2">${tempRange}</td></tr>`);
      }
    }
  } else {
    document.getElementById("overlapTableContainer").classList.add("hidden");
  }
  if (showHistogram && gcData.length > 0 && gcData.some(seq => seq.fragments.length > 0)) {
    document.getElementById("histogramContainer").classList.remove("hidden");
    drawHistogram(gcData);
  } else {
    document.getElementById("histogramContainer").classList.add("hidden");
  }
  document.getElementById("outLog").textContent = out;
  const fastaBlob = new Blob([out], {type: 'text/plain'});
  const fastaUrl = URL.createObjectURL(fastaBlob);
  const csvBlob = new Blob([csvContent], {type: 'text/csv'});
  const csvUrl = URL.createObjectURL(csvBlob);
  const downloadBtn = document.getElementById("downloadBtn");
  const copyBtn = document.getElementById("copyBtn");
  const downloadCsvBtn = document.getElementById("downloadCsvBtn");
  downloadBtn.style.display = 'inline-block';
  copyBtn.style.display = 'inline-block';
  downloadCsvBtn.style.display = allFrags.length > records.length ? 'inline-block' : 'none';
  downloadBtn.onclick = () => {
    const inputType = document.querySelector('input[name="inputType"]:checked').value;
    let filePrefix = "user_input";
    if (inputType === "file") {
      const file = document.getElementById("fastaFile").files[0];
      if (file) {
        filePrefix = file.name.split('.').slice(0, -1).join('.');
      }
    }
    const prefix = prompt("Enter a prefix for the FASTA file (optional):", filePrefix);
    const finalPrefix = prefix ? prefix : filePrefix;
    const a = document.createElement('a');
    a.href = fastaUrl;
    a.download = `${finalPrefix}_fragments.fa`;
    a.click();
  };
  copyBtn.onclick = () => {
    navigator.clipboard.writeText(out).then(() => alert("FASTA output copied to clipboard!"));
  };
  downloadCsvBtn.onclick = () => {
    const inputType = document.querySelector('input[name="inputType"]:checked').value;
    let filePrefix = "user_input";
    if (inputType === "file") {
      const file = document.getElementById("fastaFile").files[0];
      if (file) {
        filePrefix = file.name.split('.').slice(0, -1).join('.');
      }
    }
    const prefix = prompt("Enter a prefix for the CSV file (optional):", filePrefix);
    const finalPrefix = prefix ? prefix : filePrefix;
    const a = document.createElement('a');
    a.href = csvUrl;
    a.download = `${finalPrefix}_overlaps.csv`;
    a.click();
  };
  btn.disabled = false;
  btn.textContent = "Process";
  document.getElementById("progress").classList.add("hidden");
};
document.getElementById("fastaFile").addEventListener("change", () => {
  const file = document.getElementById("fastaFile").files[0];
  document.getElementById("fileName").textContent = file ? `Selected: ${file.name}` : "";
  clearOutput();
  if (file) {
    file.text().then(parseFasta);
  } else {
    document.getElementById("seqLength").textContent = "";
  }
});
document.getElementById("sequenceInput").addEventListener("input", () => {
  clearOutput();
  const text = document.getElementById("sequenceInput").value.trim();
  if (text) parseFasta(text);
});
const inputTypeRadios = document.querySelectorAll('input[name="inputType"]');
const fileInputContainer = document.getElementById("fileInputContainer");
const sequenceInputContainer = document.getElementById("sequenceInputContainer");
function toggleInputFields() {
  const inputType = document.querySelector('input[name="inputType"]:checked').value;
  if (inputType === "file") {
    fileInputContainer.classList.remove("hidden");
    sequenceInputContainer.classList.add("hidden");
    document.getElementById("sequenceInput").value = "";
    document.getElementById("seqLengthSequence").textContent = "";
    document.getElementById("exampleSequenceBtn").style.display = "none";
  } else {
    fileInputContainer.classList.add("hidden");
    sequenceInputContainer.classList.remove("hidden");
    document.getElementById("fastaFile").value = "";
    document.getElementById("fileName").textContent = "";
    document.getElementById("seqLength").textContent = "";
    document.getElementById("exampleSequenceBtn").style.display = "inline-block";
  }
  clearOutput();
}
inputTypeRadios.forEach(radio => {
  radio.addEventListener("change", toggleInputFields);
});
document.getElementById("exampleSequenceBtn").addEventListener("click", loadExampleSequence);
toggleInputFields();
document.getElementById("gcBalance").addEventListener("change", () => {
  toggleGCFields();
  saveInputs();
});
document.getElementById("toggleInstructions").onclick = () => {
  const div = document.getElementById("instructions");
  const btn = document.getElementById("toggleInstructions");
  div.classList.toggle("hidden");
  btn.textContent = div.classList.contains("hidden") ? "Show Instructions" : "Hide Instructions";
};
document.getElementById("themeToggle").addEventListener("change", () => {
  document.documentElement.dataset.theme = document.getElementById("themeToggle").checked ? "dark" : "light";
  localStorage.setItem("theme", document.documentElement.dataset.theme);
});
if (localStorage.getItem("theme") === "dark") {
  document.documentElement.dataset.theme = "dark";
  document.getElementById("themeToggle").checked = true;
}
document.querySelectorAll("#length, #overlap, #fivePrime, #threePrime, #gcMin, #gcMax, #gcBalance, #showHistogram").forEach(el => {
  el.addEventListener(el.type === "checkbox" ? "change" : "input", saveInputs);
});
loadInputs();
</script>
</body>
</html>
